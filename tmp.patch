use fil_actors_evm_shared::address::EthAddress;
use fil_actors_runtime::{
    ActorError, AsActorError, EAM_ACTOR_ADDR, INIT_ACTOR_ADDR, WithCodec,
    actor_dispatch_unrestricted, actor_error,
};
use fvm_ipld_blockstore::Blockstore;
use fvm_ipld_encoding::ipld_block::IpldBlock;
use fvm_ipld_encoding::{BytesSer, DAG_CBOR};
use fvm_shared::address::Address;
use fvm_shared::crypto::hash::SupportedHashes;
use fvm_shared::econ::TokenAmount;
use fvm_shared::error::ExitCode;

use crate::interpreter::Outcome;
use crate::interpreter::{Bytecode, ExecutionState, System, execute};
use crate::reader::ValueReader;
use cid::Cid;
use fil_actors_runtime::runtime::{ActorCode, Runtime};
// Delegator removed in this branch; 7702 mapping is internal to EVM state.
use fvm_shared::METHOD_CONSTRUCTOR;
use num_derive::FromPrimitive;

pub use types::*;

#[doc(hidden)]
pub mod ext;
pub mod interpreter;
pub(crate) mod reader;
mod state;
mod types;

pub use state::*;

#[cfg(feature = "fil-actor")]
fil_actors_runtime::wasm_trampoline!(EvmContractActor);

pub const EVM_CONTRACT_REVERTED: ExitCode = ExitCode::new(33);
pub const EVM_CONTRACT_INVALID_INSTRUCTION: ExitCode = ExitCode::new(34);
pub const EVM_CONTRACT_UNDEFINED_INSTRUCTION: ExitCode = ExitCode::new(35);
pub const EVM_CONTRACT_STACK_UNDERFLOW: ExitCode = ExitCode::new(36);
pub const EVM_CONTRACT_STACK_OVERFLOW: ExitCode = ExitCode::new(37);
pub const EVM_CONTRACT_ILLEGAL_MEMORY_ACCESS: ExitCode = ExitCode::new(38);
pub const EVM_CONTRACT_BAD_JUMPDEST: ExitCode = ExitCode::new(39);
pub const EVM_CONTRACT_SELFDESTRUCT_FAILED: ExitCode = ExitCode::new(40);

const EVM_MAX_RESERVED_METHOD: u64 = 1023;
pub const NATIVE_METHOD_SIGNATURE: &str = "handle_filecoin_method(uint64,uint64,bytes)";
pub const NATIVE_METHOD_SELECTOR: [u8; 4] = [0x86, 0x8e, 0x10, 0xc4];

const EVM_WORD_SIZE: usize = 32;

// Shared delegated event topic string for EIP-7702 attribution.
pub const DELEGATED_EVENT_TOPIC: &[u8] = b"Delegated(address)";

// Note: no actor-defined intrinsic gas charges are applied for 7702 in this branch.

#[test]
fn test_method_selector() {
    // We could just _generate_ this method selector with a proc macro, but this is easier.
    use multihash_codetable::MultihashDigest;
    let hash = multihash_codetable::Code::Keccak256.digest(NATIVE_METHOD_SIGNATURE.as_bytes());
    let computed_selector = &hash.digest()[..4];
    assert_eq!(computed_selector, NATIVE_METHOD_SELECTOR);
}

#[derive(FromPrimitive)]
#[repr(u64)]
pub enum Method {
    Constructor = METHOD_CONSTRUCTOR,
    Resurrect = 2,
    GetBytecode = 3,
    GetBytecodeHash = 4,
    GetStorageAt = 5,
    InvokeContractDelegate = 6,
    // Legacy entry removed; kept for binary compatibility of method numbers.
    InvokeAsEoa = 7,
    InvokeAsEoaWithRoot = frc42_dispatch::method_hash!("InvokeAsEoaWithRoot"),
    // New: Atomic EIP-7702 apply + call entrypoint
    // Legacy entry removed; kept for binary compatibility of method numbers.
    ApplyAndCall = frc42_dispatch::method_hash!("ApplyAndCall"),
    InvokeContract = frc42_dispatch::method_hash!("InvokeEVM"),
}

pub struct EvmContractActor;

/// Returns a tombstone for the currently executing message.
pub(crate) fn current_tombstone(rt: &impl Runtime) -> Tombstone {
    Tombstone { origin: rt.message().origin().id().unwrap(), nonce: rt.message().nonce() }
}

/// Returns true if the contract is "dead". A contract is dead if:
///
/// 1. It has a tombstone.
/// 2. It's tombstone is not from the current message execution (the nonce/origin don't match the
///    currently executing message).
///
/// Specifically, this lets us mark the contract as "self-destructed" but keep it alive until the
/// current top-level message finishes executing.
pub(crate) fn is_dead(rt: &impl Runtime, state: &State) -> bool {
    state.tombstone.is_some_and(|t| t != current_tombstone(rt))
}

fn load_bytecode(bs: &impl Blockstore, cid: &Cid) -> Result<Option<Bytecode>, ActorError> {
    let bytecode = bs
        .get(cid)
        .context_code(ExitCode::USR_NOT_FOUND, "failed to read bytecode")?
        .expect("bytecode not in state tree");
    if bytecode.is_empty() { Ok(None) } else { Ok(Some(Bytecode::new(bytecode))) }
}

fn initialize_evm_contract(
    system: &mut System<impl Runtime>,
    caller: EthAddress,
    initcode: Vec<u8>,
) -> Result<(), ActorError> {
    // Lookup our Ethereum address.
    let receiver_fil_addr = system.rt.message().receiver();
    let receiver_eth_addr = system.resolve_ethereum_address(&receiver_fil_addr).context_code(
        ExitCode::USR_ASSERTION_FAILED,
        "failed to resolve the contracts ETH address",
    )?;

    // Make sure we have an actual Ethereum address (assigned by the EAM). This is how we make sure
    // an EVM actor may only be constructed by the EAM.
    if receiver_eth_addr.as_id().is_some() {
        return Err(ActorError::forbidden(format!(
            "contract {} doesn't have an eth address",
            receiver_fil_addr,
        )));
    }

    // If we have no code, save the state and return.
    if initcode.is_empty() {
        return system.flush();
    }

    // create a new execution context
    let value_received = system.rt.message().value_received();
    let mut exec_state = ExecutionState::new(caller, receiver_eth_addr, value_received, Vec::new());

    // identify bytecode valid jump destinations
    let initcode = Bytecode::new(initcode);

    // invoke the contract constructor
    let output = execute(&initcode, &mut exec_state, system)?;

    match output.outcome {
        Outcome::Return => {
            system.set_bytecode(&output.return_data)?;
            system.flush()
        }
        Outcome::Revert => Err(ActorError::unchecked_with_data(
            EVM_CONTRACT_REVERTED,
            "constructor reverted".to_string(),
            IpldBlock::serialize_cbor(&BytesSer(&output.return_data)).unwrap(),
        )),
    }
}

fn invoke_contract_inner<RT>(
    system: &mut System<RT>,
    input_data: Vec<u8>,
    bytecode_cid: &Cid,
    caller: &EthAddress,
    value_received: TokenAmount,
) -> Result<Vec<u8>, ActorError>
where
    RT: Runtime,
    RT::Blockstore: Clone,
{
    let bytecode = match load_bytecode(system.rt.store(), bytecode_cid)? {
        Some(bytecode) => bytecode,
        // an EVM contract with no code returns immediately
        None => return Ok(Vec::new()),
    };

    // Resolve the receiver's ethereum address.
    let receiver_fil_addr = system.rt.message().receiver();
    let receiver_eth_addr = system.resolve_ethereum_address(&receiver_fil_addr).unwrap();

    let mut exec_state =
        ExecutionState::new(*caller, receiver_eth_addr, value_received, input_data);

    let output = execute(&bytecode, &mut exec_state, system)?;

    match output.outcome {
        Outcome::Return => {
            system.flush()?;
            Ok(output.return_data.to_vec())
        }
        Outcome::Revert => Err(ActorError::unchecked_with_data(
            EVM_CONTRACT_REVERTED,
            format!("contract reverted at {0}", output.pc),
            IpldBlock::serialize_cbor(&BytesSer(&output.return_data)).unwrap(),
        )),
    }
}

impl EvmContractActor {
    /// Legacy InvokeAsEoa has been removed; keep stub returning illegal_state.
    pub fn invoke_as_eoa<RT>(
        _rt: &RT,
        _params: WithCodec<EoaInvokeParams, DAG_CBOR>,
    ) -> Result<InvokeContractReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        Err(ActorError::illegal_state("InvokeAsEoa has been removed on this branch".into()))
    }
    pub fn constructor<RT>(rt: &RT, params: ConstructorParams) -> Result<(), ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        rt.validate_immediate_caller_is(&[INIT_ACTOR_ADDR])?;
        initialize_evm_contract(&mut System::create(rt)?, params.creator, params.initcode.into())
    }

    pub fn resurrect<RT>(rt: &RT, params: ResurrectParams) -> Result<(), ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        rt.validate_immediate_caller_is(&[EAM_ACTOR_ADDR])?;
        initialize_evm_contract(&mut System::resurrect(rt)?, params.creator, params.initcode.into())
    }

    /// Invoke the contract with some _alternative_ bytecode. This can only be called by the
    /// contract itself and is used to implement the EVM's DELEGATECALL opcode.
    ///
    /// This method expects DAG_CBOR encoded parameters (the linked `params.code` needs to be
    /// reachable).
    pub fn invoke_contract_delegate<RT>(
        rt: &RT,
        params: WithCodec<DelegateCallParams, DAG_CBOR>,
    ) -> Result<DelegateCallReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        let params = params.0;
        rt.validate_immediate_caller_is(&[rt.message().receiver()])?;

        let mut system = System::load(rt).map_err(|e| {
            ActorError::unspecified(format!("failed to create execution abstraction layer: {e:?}"))
        })?;
        let return_data = invoke_contract_inner(
            &mut system,
            params.input,
            &params.code,
            &params.caller,
            params.value,
        )?;
        Ok(DelegateCallReturn { return_data })
    }

    // invoke_as_eoa removed; VM uses invoke_as_eoa_with_root trampoline.

    /// Execute delegate bytecode under authority context mounting the provided storage root.
    /// Returns both output bytes and the updated storage root. This is intended to be called
    /// only by the VM intercept path; immediate caller must be self.
    pub fn invoke_as_eoa_with_root<RT>(
        rt: &RT,
        params: WithCodec<crate::InvokeAsEoaWithRootParams, DAG_CBOR>,
    ) -> Result<crate::InvokeAsEoaWithRootReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        rt.validate_immediate_caller_is(&[rt.message().receiver()])?;

        let p = params.0;
        let mut system = System::load(rt).map_err(|e| {
            ActorError::unspecified(format!("failed to create execution abstraction layer: {e:?}"))
        })?;

        // Load bytecode to execute.
        let bytecode = match load_bytecode(system.rt.store(), &p.code)? {
            Some(b) => b,
            None => {
                // Nothing to execute; return the same root.
                return Ok(crate::InvokeAsEoaWithRootReturn {
                    output_data: Vec::new(),
                    new_storage_root: p.initial_storage_root,
                });
            }
        };

        // Mount the provided authority storage root.
        let actor_storage_root = system.flush_storage_root()?;
        system.mount_storage_root(&p.initial_storage_root)?;
        // Enter authority context (depth=1).
        let prev_ctx = system.in_authority_context;
        system.in_authority_context = true;

        // Execute with explicit caller/receiver/value.
        let mut exec_state = ExecutionState::new(p.caller, p.receiver, p.value, p.input);
        let output = execute(&bytecode, &mut exec_state, &mut system)?;
        match output.outcome {
            Outcome::Return => {
                let new_root = system.flush_storage_root()?;
                system.mount_storage_root(&actor_storage_root)?;
                system.in_authority_context = prev_ctx;
                system.flush()?;
                Ok(crate::InvokeAsEoaWithRootReturn {
                    output_data: output.return_data.to_vec(),
                    new_storage_root: new_root,
                })
            }
            Outcome::Revert => {
                // Restore and propagate revert via unchecked error with data encoded as raw bytes.
                system.mount_storage_root(&actor_storage_root)?;
                system.in_authority_context = prev_ctx;
                Err(ActorError::unchecked_with_data(
                    EVM_CONTRACT_REVERTED,
                    format!("contract reverted at {0}", output.pc),
                    IpldBlock::serialize_cbor(&BytesSer(&output.return_data)).unwrap(),
                ))
            }
        }
    }

    // Legacy ApplyAndCall route removed in favor of EthAccount.ApplyAndCall + VM intercept.
    fn apply_and_call_removed<RT>(
        _rt: &RT,
        _params: WithCodec<crate::ApplyAndCallParams, DAG_CBOR>,
    ) -> Result<crate::ApplyAndCallReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        Err(ActorError::illegal_state(
            "EVM.ApplyAndCall has been removed on this branch".into(),
        ))
    }

    pub fn invoke_contract<RT>(
        rt: &RT,
        params: InvokeContractParams,
    ) -> Result<InvokeContractReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        rt.validate_immediate_caller_accept_any()?;

        let mut system = System::load(rt).map_err(|e| {
            ActorError::unspecified(format!("failed to create execution abstraction layer: {e:?}"))
        })?;

        let bytecode_cid = match system.get_bytecode() {
            Some(bytecode_cid) => bytecode_cid,
            // an EVM contract with no code returns immediately
            None => return Ok(InvokeContractReturn { output_data: Vec::new() }),
        };

        let received_value = system.rt.message().value_received();
        let caller = system.resolve_ethereum_address(&system.rt.message().caller()).unwrap();
        let data = invoke_contract_inner(
            &mut system,
            params.input_data,
            &bytecode_cid,
            &caller,
            received_value,
        )?;
        Ok(InvokeContractReturn { output_data: data })
    }

    pub fn handle_filecoin_method<RT>(
        rt: &RT,
        method: u64,
        args: Option<IpldBlock>,
    ) -> Result<Option<IpldBlock>, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        if method <= EVM_MAX_RESERVED_METHOD {
            return Err(actor_error!(unhandled_message; "Invalid method"));
        }
        let params = args.unwrap_or(IpldBlock { codec: 0, data: vec![] });
        let input = handle_filecoin_method_input(method, params.codec, params.data.as_slice());
        let output = Self::invoke_contract(rt, InvokeContractParams { input_data: input })?;
        handle_filecoin_method_output(&output.output_data)
    }

    /// Returns the contract's EVM bytecode, or `None` if the contract has been deleted (has called
    /// SELFDESTRUCT).
    ///
    /// Return value is "dag cbor" as we need the linked bytecode (if present) to be reachable.
    pub fn bytecode(rt: &impl Runtime) -> Result<WithCodec<BytecodeReturn, DAG_CBOR>, ActorError> {
        // Any caller can fetch the bytecode of a contract; this is now EXT* opcodes work.
        rt.validate_immediate_caller_accept_any()?;

        let state: State = rt.state()?;
        if is_dead(rt, &state) {
            Ok(BytecodeReturn { code: None }.into())
        } else {
            Ok(BytecodeReturn { code: Some(state.bytecode) }.into())
        }
    }

    pub fn bytecode_hash(rt: &impl Runtime) -> Result<BytecodeHash, ActorError> {
        // Any caller can fetch the bytecode hash of a contract; this is where EXTCODEHASH gets it's value for EVM contracts.
        rt.validate_immediate_caller_accept_any()?;

        // return value must be either keccak("") or keccak(bytecode)
        let state: State = rt.state()?;
        if is_dead(rt, &state) { Ok(BytecodeHash::EMPTY) } else { Ok(state.bytecode_hash) }
    }

    pub fn storage_at<RT>(
        rt: &RT,
        params: GetStorageAtParams,
    ) -> Result<GetStorageAtReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        // This method cannot be called on-chain; other on-chain logic should not be able to
        // access arbitrary storage keys from a contract.
        rt.validate_immediate_caller_is([&Address::new_id(0)])?;

        // If the contract is dead, this will always return "0".
        let val = System::load(rt)?
            .get_storage(params.storage_key)
            .context_code(ExitCode::USR_ASSERTION_FAILED, "failed to get storage key")?;

        Ok(GetStorageAtReturn { storage: val })
    }
}

/// Format "filecoin_native_method" input parameters.
fn handle_filecoin_method_input(method: u64, codec: u64, params: &[u8]) -> Vec<u8> {
    let static_args =
        [method, codec, EVM_WORD_SIZE as u64 * 3 /* start of params */, params.len() as u64];
    let total_words =
        static_args.len() + (params.len() / EVM_WORD_SIZE) + (params.len() % 32 > 0) as usize;
    let len = 4 + total_words * EVM_WORD_SIZE;
    let mut buf = Vec::with_capacity(len);
    buf.extend_from_slice(&NATIVE_METHOD_SELECTOR);
    for n in static_args {
        // Left-pad to 32 bytes, then be-encode the value.
        let encoded = n.to_be_bytes();
        buf.resize(buf.len() + (EVM_WORD_SIZE - encoded.len()), 0);
        buf.extend_from_slice(&encoded);
    }
    // Extend with the params, then right-pad with zeros.
    buf.extend_from_slice(params);
    buf.resize(len, 0);
    buf
}

/// Decode the response from "filecoin_native_method". We expect:
///
/// 1. The exit code (u32).
/// 2. The codec (u64).
/// 3. The data (bytes).
///
/// According to the solidity ABI.
fn handle_filecoin_method_output(output: &[u8]) -> Result<Option<IpldBlock>, ActorError> {
    // Short-circuit if empty.
    if output.is_empty() {
        return Ok(None);
    }
    let mut output = ValueReader::new(output);

    let exit_code: ExitCode =
        output.read_value().context_code(ExitCode::USR_SERIALIZATION, "exit code not a u32")?;
    let codec: u64 = output
        .read_value()
        .context_code(ExitCode::USR_SERIALIZATION, "returned codec not a u64")?;
    let len_offset: u32 = output
        .read_value()
        .context_code(ExitCode::USR_SERIALIZATION, "invalid return value offset")?;

    output.seek(len_offset as usize);
    let length: u32 = output
        .read_value()
        .context_code(ExitCode::USR_SERIALIZATION, "return length is too large")?;
    let return_data = output.read_padded(length as usize);

    let return_block = match codec {
        // Empty return values.
        0 if length == 0 => None,
        0 => {
            return Err(ActorError::serialization(format!(
                "codec 0 is only valid for empty returns, got a return value of length {length}"
            )));
        }
        // Supported codecs.
        fvm_ipld_encoding::CBOR => Some(IpldBlock { codec, data: return_data.into() }),
        // Everything else.
        _ => return Err(ActorError::serialization(format!("unsupported codec: {codec}"))),
    };

    if exit_code.is_success() {
        Ok(return_block)
    } else {
        Err(ActorError::unchecked_with_data(
            exit_code,
            "EVM contract explicitly exited with a non-zero exit code".to_string(),
            return_block,
        ))
    }
}

impl ActorCode for EvmContractActor {
    type Methods = Method;

    fn name() -> &'static str {
        "EVMContract"
    }

    actor_dispatch_unrestricted! {
        Constructor => constructor,
        InvokeContract => invoke_contract [default_params],
        GetBytecode => bytecode,
        GetBytecodeHash => bytecode_hash,
        GetStorageAt => storage_at,
        InvokeContractDelegate => invoke_contract_delegate,
        // Legacy ApplyAndCall/InvokeAsEoa removed; map to stubs returning illegal_state.
        InvokeAsEoa => invoke_as_eoa,
        ApplyAndCall => apply_and_call_removed,
        // Keep only InvokeAsEoaWithRoot for VM intercepts.
        InvokeAsEoaWithRoot => invoke_as_eoa_with_root,
        Resurrect => resurrect,
        _ => handle_filecoin_method,
    }
}

#[derive(
    Clone, Debug, fvm_ipld_encoding::serde::Serialize, fvm_ipld_encoding::serde::Deserialize,
)]
pub struct EoaInvokeParams {
    pub code: Cid,
    #[serde(with = "fvm_ipld_encoding::strict_bytes")]
    pub input: Vec<u8>,
    pub caller: EthAddress,
    pub receiver: EthAddress,
    pub value: TokenAmount,
}

impl EvmContractActor {
    fn validate_tuple(rt: &impl Runtime, t: &crate::DelegationParam) -> Result<(), ActorError> {
        // chain id 0 or local
        if t.chain_id != 0 && fvm_shared::chainid::ChainID::from(t.chain_id) != rt.chain_id() {
            return Err(ActorError::illegal_argument("invalid chain id".into()));
        }
        // Length checks first: r,s must be <= 32 bytes.
        if t.r.len() > 32 {
            return Err(ActorError::illegal_argument("r length exceeds 32".into()));
        }
        if t.s.len() > 32 {
            return Err(ActorError::illegal_argument("s length exceeds 32".into()));
        }
        // r/s non-zero
        if t.r.iter().all(|&b| b == 0) || t.s.iter().all(|&b| b == 0) {
            return Err(ActorError::illegal_argument("zero r/s".into()));
        }
        // y_parity 0 or 1
        if t.y_parity != 0 && t.y_parity != 1 {
            return Err(ActorError::illegal_argument("invalid y_parity".into()));
        }
        // low-s: s <= n/2, run on 32-byte left-padded S
        let mut s_padded = [0u8; 32];
        let s_in = &t.s;
        let start = 32 - s_in.len();
        s_padded[start..].copy_from_slice(s_in);
        if Self::is_high_s(&s_padded) {
            return Err(ActorError::illegal_argument("high-s not allowed".into()));
        }
        Ok(())
    }

    fn is_high_s(sv: &[u8; 32]) -> bool {
        // n/2 as in Delegator
        const N: [u8; 32] = [
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C,
            0xD0, 0x36, 0x41, 0x41,
        ];
        let mut n2 = [0u8; 32];
        let mut carry = 0u16;
        for i in (0..32).rev() {
            let v = (carry << 8) | N[i] as u16;
            n2[i] = (v / 2) as u8;
            carry = v % 2;
        }
        sv > &n2
    }

    fn recover_authority(
        rt: &impl Runtime,
        t: &crate::DelegationParam,
    ) -> Result<EthAddress, ActorError> {
        // message = keccak256(0x05 || rlp([chain_id, address(20), nonce]))
        let mut s = rlp::RlpStream::new_list(3);
        s.append(&t.chain_id);
        s.append(&t.address.as_ref());
        s.append(&t.nonce);
        let rlp_bytes = s.out().to_vec();
        let mut preimage = Vec::with_capacity(1 + rlp_bytes.len());
        preimage.push(0x05u8);
        preimage.extend_from_slice(&rlp_bytes);
        let mut hash32 = [0u8; 32];
        let h = rt.hash(fvm_shared::crypto::hash::SupportedHashes::Keccak256, &preimage);
        hash32.copy_from_slice(&h);

        // build 65-byte signature r||s||v (accept <=32-byte r/s; left-pad to 32)
        let mut sig = [0u8; 65];
        let r_start = 32 - t.r.len();
        sig[r_start..32].copy_from_slice(&t.r);
        let s_start = 64 - t.s.len();
        sig[s_start..64].copy_from_slice(&t.s);
        sig[64] = t.y_parity;
        let pubkey = rt
            .recover_secp_public_key(&hash32, &sig)
            .map_err(|e| ActorError::illegal_argument(format!("signature recovery failed: {e}")))?;
        let (keccak64, _len) =
            rt.hash_64(fvm_shared::crypto::hash::SupportedHashes::Keccak256, &pubkey[1..]);
        let mut addr = [0u8; 20];
        addr.copy_from_slice(&keccak64[12..32]);
        Ok(EthAddress(addr))
    }
    pub fn apply_and_call<RT>(
        _rt: &RT,
        _params: WithCodec<crate::ApplyAndCallParams, DAG_CBOR>,
    ) -> Result<crate::ApplyAndCallReturn, ActorError>
    where
        RT: Runtime,
        RT::Blockstore: Clone,
    {
        Err(ActorError::illegal_state("EVM.ApplyAndCall has been removed on this branch".into()))
    }
}
