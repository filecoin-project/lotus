// Code generated by mockery v1.0.0. DO NOT EDIT.

// Generated by: mockery -dir api -name FullNode -outpkg smm -output smm -testonly

package smm

import actors "github.com/filecoin-project/lotus/chain/actors"
import address "github.com/filecoin-project/lotus/chain/address"
import api "github.com/filecoin-project/lotus/api"
import cid "github.com/ipfs/go-cid"
import context "context"
import mock "github.com/stretchr/testify/mock"
import network "github.com/libp2p/go-libp2p-core/network"
import peer "github.com/libp2p/go-libp2p-core/peer"
import store "github.com/filecoin-project/lotus/chain/store"
import types "github.com/filecoin-project/lotus/chain/types"

// FullNode is an autogenerated mock type for the FullNode type
type FullNode struct {
	mock.Mock
}

// AuthNew provides a mock function with given fields: ctx, perms
func (_m *FullNode) AuthNew(ctx context.Context, perms []string) ([]byte, error) {
	ret := _m.Called(ctx, perms)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, []string) []byte); ok {
		r0 = rf(ctx, perms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, perms)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthVerify provides a mock function with given fields: ctx, token
func (_m *FullNode) AuthVerify(ctx context.Context, token string) ([]string, error) {
	ret := _m.Called(ctx, token)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetBlock provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetBlock(_a0 context.Context, _a1 cid.Cid) (*types.BlockHeader, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.BlockHeader
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.BlockHeader); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetBlockMessages provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetBlockMessages(_a0 context.Context, _a1 cid.Cid) (*api.BlockMessages, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.BlockMessages
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.BlockMessages); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BlockMessages)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetGenesis provides a mock function with given fields: _a0
func (_m *FullNode) ChainGetGenesis(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentMessages provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetParentMessages(_a0 context.Context, _a1 cid.Cid) ([]api.Message, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []api.Message
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.Message); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentReceipts provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetParentReceipts(_a0 context.Context, _a1 cid.Cid) ([]*types.MessageReceipt, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*types.MessageReceipt
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []*types.MessageReceipt); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.MessageReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetRandomness provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) ChainGetRandomness(_a0 context.Context, _a1 types.TipSetKey, _a2 []*types.Ticket, _a3 int) ([]byte, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, []*types.Ticket, int) []byte); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, []*types.Ticket, int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSet provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetTipSet(_a0 context.Context, _a1 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSetByHeight provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) ChainGetTipSetByHeight(_a0 context.Context, _a1 uint64, _a2 *types.TipSet) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *types.TipSet) *types.TipSet); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHead provides a mock function with given fields: _a0
func (_m *FullNode) ChainHead(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainNotify provides a mock function with given fields: _a0
func (_m *FullNode) ChainNotify(_a0 context.Context) (<-chan []*store.HeadChange, error) {
	ret := _m.Called(_a0)

	var r0 <-chan []*store.HeadChange
	if rf, ok := ret.Get(0).(func(context.Context) <-chan []*store.HeadChange); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []*store.HeadChange)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainReadObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainReadObj(_a0 context.Context, _a1 cid.Cid) ([]byte, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainSetHead provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainSetHead(_a0 context.Context, _a1 *types.TipSet) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainTipSetWeight provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainTipSetWeight(_a0 context.Context, _a1 *types.TipSet) (types.BigInt, error) {
	ret := _m.Called(_a0, _a1)

	var r0 types.BigInt
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) types.BigInt); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientFindData provides a mock function with given fields: ctx, root
func (_m *FullNode) ClientFindData(ctx context.Context, root cid.Cid) ([]api.QueryOffer, error) {
	ret := _m.Called(ctx, root)

	var r0 []api.QueryOffer
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.QueryOffer); ok {
		r0 = rf(ctx, root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.QueryOffer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientGetDealInfo provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ClientGetDealInfo(_a0 context.Context, _a1 cid.Cid) (*api.DealInfo, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.DealInfo
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.DealInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DealInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientHasLocal provides a mock function with given fields: ctx, root
func (_m *FullNode) ClientHasLocal(ctx context.Context, root cid.Cid) (bool, error) {
	ret := _m.Called(ctx, root)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) bool); ok {
		r0 = rf(ctx, root)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientImport provides a mock function with given fields: ctx, path
func (_m *FullNode) ClientImport(ctx context.Context, path string) (cid.Cid, error) {
	ret := _m.Called(ctx, path)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, string) cid.Cid); ok {
		r0 = rf(ctx, path)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientListDeals provides a mock function with given fields: ctx
func (_m *FullNode) ClientListDeals(ctx context.Context) ([]api.DealInfo, error) {
	ret := _m.Called(ctx)

	var r0 []api.DealInfo
	if rf, ok := ret.Get(0).(func(context.Context) []api.DealInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.DealInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientListImports provides a mock function with given fields: ctx
func (_m *FullNode) ClientListImports(ctx context.Context) ([]api.Import, error) {
	ret := _m.Called(ctx)

	var r0 []api.Import
	if rf, ok := ret.Get(0).(func(context.Context) []api.Import); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Import)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientQueryAsk provides a mock function with given fields: ctx, p, miner
func (_m *FullNode) ClientQueryAsk(ctx context.Context, p peer.ID, miner address.Address) (*types.SignedStorageAsk, error) {
	ret := _m.Called(ctx, p, miner)

	var r0 *types.SignedStorageAsk
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, address.Address) *types.SignedStorageAsk); ok {
		r0 = rf(ctx, p, miner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedStorageAsk)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, address.Address) error); ok {
		r1 = rf(ctx, p, miner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientRetrieve provides a mock function with given fields: ctx, order, path
func (_m *FullNode) ClientRetrieve(ctx context.Context, order api.RetrievalOrder, path string) error {
	ret := _m.Called(ctx, order, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.RetrievalOrder, string) error); ok {
		r0 = rf(ctx, order, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientStartDeal provides a mock function with given fields: ctx, data, miner, epochPrice, blocksDuration
func (_m *FullNode) ClientStartDeal(ctx context.Context, data cid.Cid, miner address.Address, epochPrice types.BigInt, blocksDuration uint64) (*cid.Cid, error) {
	ret := _m.Called(ctx, data, miner, epochPrice, blocksDuration)

	var r0 *cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, address.Address, types.BigInt, uint64) *cid.Cid); ok {
		r0 = rf(ctx, data, miner, epochPrice, blocksDuration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cid.Cid)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, address.Address, types.BigInt, uint64) error); ok {
		r1 = rf(ctx, data, miner, epochPrice, blocksDuration)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ID provides a mock function with given fields: _a0
func (_m *FullNode) ID(_a0 context.Context) (peer.ID, error) {
	ret := _m.Called(_a0)

	var r0 peer.ID
	if rf, ok := ret.Get(0).(func(context.Context) peer.ID); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MarketEnsureAvailable provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MarketEnsureAvailable(_a0 context.Context, _a1 address.Address, _a2 types.BigInt) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.BigInt) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MinerAddresses provides a mock function with given fields: _a0
func (_m *FullNode) MinerAddresses(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerCreateBlock provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MinerCreateBlock(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet, _a3 []*types.Ticket, _a4 types.ElectionProof, _a5 []*types.SignedMessage, _a6 uint64) (*types.BlockMsg, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	var r0 *types.BlockMsg
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet, []*types.Ticket, types.ElectionProof, []*types.SignedMessage, uint64) *types.BlockMsg); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockMsg)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet, []*types.Ticket, types.ElectionProof, []*types.SignedMessage, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerRegister provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MinerRegister(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MinerUnregister provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MinerUnregister(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MpoolGetNonce provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolGetNonce(_a0 context.Context, _a1 address.Address) (uint64, error) {
	ret := _m.Called(_a0, _a1)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPending provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPending(_a0 context.Context, _a1 *types.TipSet) ([]*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) []*types.SignedMessage); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPush provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPush(_a0 context.Context, _a1 *types.SignedMessage) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MpoolPushMessage provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPushMessage(_a0 context.Context, _a1 *types.Message) (*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message) *types.SignedMessage); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Message) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetAddrsListen provides a mock function with given fields: _a0
func (_m *FullNode) NetAddrsListen(_a0 context.Context) (peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	var r0 peer.AddrInfo
	if rf, ok := ret.Get(0).(func(context.Context) peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetConnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnect(_a0 context.Context, _a1 peer.AddrInfo) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetConnectedness provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnectedness(_a0 context.Context, _a1 peer.ID) (network.Connectedness, error) {
	ret := _m.Called(_a0, _a1)

	var r0 network.Connectedness
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) network.Connectedness); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(network.Connectedness)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetDisconnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetDisconnect(_a0 context.Context, _a1 peer.ID) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetPeers provides a mock function with given fields: _a0
func (_m *FullNode) NetPeers(_a0 context.Context) ([]peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	var r0 []peer.AddrInfo
	if rf, ok := ret.Get(0).(func(context.Context) []peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.AddrInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychAllocateLane provides a mock function with given fields: ctx, ch
func (_m *FullNode) PaychAllocateLane(ctx context.Context, ch address.Address) (uint64, error) {
	ret := _m.Called(ctx, ch)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(ctx, ch)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychClose provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychClose(_a0 context.Context, _a1 address.Address) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychGet provides a mock function with given fields: ctx, from, to, ensureFunds
func (_m *FullNode) PaychGet(ctx context.Context, from address.Address, to address.Address, ensureFunds types.BigInt) (*api.ChannelInfo, error) {
	ret := _m.Called(ctx, from, to, ensureFunds)

	var r0 *api.ChannelInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, types.BigInt) *api.ChannelInfo); ok {
		r0 = rf(ctx, from, to, ensureFunds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, types.BigInt) error); ok {
		r1 = rf(ctx, from, to, ensureFunds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychList provides a mock function with given fields: _a0
func (_m *FullNode) PaychList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychNewPayment provides a mock function with given fields: ctx, from, to, vouchers
func (_m *FullNode) PaychNewPayment(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec) (*api.PaymentInfo, error) {
	ret := _m.Called(ctx, from, to, vouchers)

	var r0 *api.PaymentInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) *api.PaymentInfo); ok {
		r0 = rf(ctx, from, to, vouchers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaymentInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) error); ok {
		r1 = rf(ctx, from, to, vouchers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychStatus provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychStatus(_a0 context.Context, _a1 address.Address) (*api.PaychStatus, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.PaychStatus
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *api.PaychStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaychStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherAdd provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherAdd(_a0 context.Context, _a1 address.Address, _a2 *types.SignedVoucher, _a3 []byte, _a4 types.BigInt) (types.BigInt, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 types.BigInt
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.SignedVoucher, []byte, types.BigInt) types.BigInt); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.SignedVoucher, []byte, types.BigInt) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckSpendable provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherCheckSpendable(_a0 context.Context, _a1 address.Address, _a2 *types.SignedVoucher, _a3 []byte, _a4 []byte) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.SignedVoucher, []byte, []byte) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.SignedVoucher, []byte, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckValid provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) PaychVoucherCheckValid(_a0 context.Context, _a1 address.Address, _a2 *types.SignedVoucher) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.SignedVoucher) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PaychVoucherCreate provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) PaychVoucherCreate(_a0 context.Context, _a1 address.Address, _a2 types.BigInt, _a3 uint64) (*types.SignedVoucher, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 *types.SignedVoucher
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.BigInt, uint64) *types.SignedVoucher); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedVoucher)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.BigInt, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherList provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychVoucherList(_a0 context.Context, _a1 address.Address) ([]*types.SignedVoucher, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*types.SignedVoucher
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) []*types.SignedVoucher); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedVoucher)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherSubmit provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) PaychVoucherSubmit(_a0 context.Context, _a1 address.Address, _a2 *types.SignedVoucher) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.SignedVoucher) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.SignedVoucher) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCall provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateCall(_a0 context.Context, _a1 *types.Message, _a2 *types.TipSet) (*types.MessageReceipt, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.MessageReceipt
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, *types.TipSet) *types.MessageReceipt); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MessageReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetActor provides a mock function with given fields: ctx, actor, ts
func (_m *FullNode) StateGetActor(ctx context.Context, actor address.Address, ts *types.TipSet) (*types.Actor, error) {
	ret := _m.Called(ctx, actor, ts)

	var r0 *types.Actor
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) *types.Actor); ok {
		r0 = rf(ctx, actor, ts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Actor)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(ctx, actor, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListActors provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListActors(_a0 context.Context, _a1 *types.TipSet) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListMiners provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListMiners(_a0 context.Context, _a1 *types.TipSet) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketBalance(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) (actors.StorageParticipantBalance, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 actors.StorageParticipantBalance
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) actors.StorageParticipantBalance); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(actors.StorageParticipantBalance)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketDeals provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketDeals(_a0 context.Context, _a1 *types.TipSet) (map[string]actors.OnChainDeal, error) {
	ret := _m.Called(_a0, _a1)

	var r0 map[string]actors.OnChainDeal
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) map[string]actors.OnChainDeal); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]actors.OnChainDeal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketParticipants provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketParticipants(_a0 context.Context, _a1 *types.TipSet) (map[string]actors.StorageParticipantBalance, error) {
	ret := _m.Called(_a0, _a1)

	var r0 map[string]actors.StorageParticipantBalance
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) map[string]actors.StorageParticipantBalance); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]actors.StorageParticipantBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketStorageDeal provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketStorageDeal(_a0 context.Context, _a1 uint64, _a2 *types.TipSet) (*actors.OnChainDeal, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *actors.OnChainDeal
	if rf, ok := ret.Get(0).(func(context.Context, uint64, *types.TipSet) *actors.OnChainDeal); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*actors.OnChainDeal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPeerID provides a mock function with given fields: ctx, m, ts
func (_m *FullNode) StateMinerPeerID(ctx context.Context, m address.Address, ts *types.TipSet) (peer.ID, error) {
	ret := _m.Called(ctx, m, ts)

	var r0 peer.ID
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) peer.ID); ok {
		r0 = rf(ctx, m, ts)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(ctx, m, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPower provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerPower(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) (api.MinerPower, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 api.MinerPower
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) api.MinerPower); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MinerPower)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerProvingPeriodEnd provides a mock function with given fields: ctx, actor, ts
func (_m *FullNode) StateMinerProvingPeriodEnd(ctx context.Context, actor address.Address, ts *types.TipSet) (uint64, error) {
	ret := _m.Called(ctx, actor, ts)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) uint64); ok {
		r0 = rf(ctx, actor, ts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(ctx, actor, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerProvingSet provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerProvingSet(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) ([]*api.ChainSectorInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 []*api.ChainSectorInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) []*api.ChainSectorInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChainSectorInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectorSize provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerSectorSize(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) (uint64, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) uint64); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectors provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerSectors(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) ([]*api.ChainSectorInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 []*api.ChainSectorInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) []*api.ChainSectorInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChainSectorInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerWorker provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerWorker(_a0 context.Context, _a1 address.Address, _a2 *types.TipSet) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.TipSet) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StatePledgeCollateral provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StatePledgeCollateral(_a0 context.Context, _a1 *types.TipSet) (types.BigInt, error) {
	ret := _m.Called(_a0, _a1)

	var r0 types.BigInt
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet) types.BigInt); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReadState provides a mock function with given fields: ctx, act, ts
func (_m *FullNode) StateReadState(ctx context.Context, act *types.Actor, ts *types.TipSet) (*api.ActorState, error) {
	ret := _m.Called(ctx, act, ts)

	var r0 *api.ActorState
	if rf, ok := ret.Get(0).(func(context.Context, *types.Actor, *types.TipSet) *api.ActorState); ok {
		r0 = rf(ctx, act, ts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ActorState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Actor, *types.TipSet) error); ok {
		r1 = rf(ctx, act, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReplay provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateReplay(_a0 context.Context, _a1 *types.TipSet, _a2 cid.Cid) (*api.ReplayResults, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *api.ReplayResults
	if rf, ok := ret.Get(0).(func(context.Context, *types.TipSet, cid.Cid) *api.ReplayResults); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ReplayResults)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.TipSet, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateWaitMsg provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateWaitMsg(_a0 context.Context, _a1 cid.Cid) (*api.MsgWait, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.MsgWait
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.MsgWait); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgWait)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncState provides a mock function with given fields: _a0
func (_m *FullNode) SyncState(_a0 context.Context) (*api.SyncState, error) {
	ret := _m.Called(_a0)

	var r0 *api.SyncState
	if rf, ok := ret.Get(0).(func(context.Context) *api.SyncState); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SyncState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncSubmitBlock provides a mock function with given fields: ctx, blk
func (_m *FullNode) SyncSubmitBlock(ctx context.Context, blk *types.BlockMsg) error {
	ret := _m.Called(ctx, blk)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.BlockMsg) error); ok {
		r0 = rf(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Version provides a mock function with given fields: _a0
func (_m *FullNode) Version(_a0 context.Context) (api.Version, error) {
	ret := _m.Called(_a0)

	var r0 api.Version
	if rf, ok := ret.Get(0).(func(context.Context) api.Version); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(api.Version)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletBalance provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletBalance(_a0 context.Context, _a1 address.Address) (types.BigInt, error) {
	ret := _m.Called(_a0, _a1)

	var r0 types.BigInt
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) types.BigInt); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(types.BigInt)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletDefaultAddress provides a mock function with given fields: _a0
func (_m *FullNode) WalletDefaultAddress(_a0 context.Context) (address.Address, error) {
	ret := _m.Called(_a0)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context) address.Address); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletExport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletExport(_a0 context.Context, _a1 address.Address) (*types.KeyInfo, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.KeyInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *types.KeyInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.KeyInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletHas provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletHas(_a0 context.Context, _a1 address.Address) (bool, error) {
	ret := _m.Called(_a0, _a1)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletImport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletImport(_a0 context.Context, _a1 *types.KeyInfo) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.KeyInfo) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletList provides a mock function with given fields: _a0
func (_m *FullNode) WalletList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletNew provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletNew(_a0 context.Context, _a1 string) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, string) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSetDefault provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletSetDefault(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletSign provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSign(_a0 context.Context, _a1 address.Address, _a2 []byte) (*types.Signature, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.Signature
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte) *types.Signature); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSignMessage provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSignMessage(_a0 context.Context, _a1 address.Address, _a2 *types.Message) (*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) *types.SignedMessage); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.Message) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
