This document synthesizes the provided notes into a comprehensive overview and technical deep dive of the EIP-7702 implementation within the Filecoin network.

# Filecoin EVM + EIP-7702 (“Delegated EOAs”) — Implementation Overview

> **Audience:** Filecoin core developers, Lotus node operators, and technically-savvy contributors/auditors.
> **Scope:** This document details the integration of Ethereum’s **EIP-7702** into Filecoin’s EVM, synthesizing the architectural design and the interaction between the Go-based Lotus client and the Rust-based FVM (`builtin-actors`).

-----

## 0\. Understanding EIP-7702 in Filecoin

EIP-7702 introduces a mechanism allowing Externally Owned Accounts (EOAs) to temporarily adopt smart contract functionality. It lets an EOA delegate its execution context to a specified contract by publishing a signed **authorization tuple** via a new transaction type (`0x04`).

In this Filecoin integration, we implement an EVM‑only architecture:

  * **Persist Delegations (EVM Actor):** Delegation choices and per‑authority nonces are stored inside the EVM actor’s state.
  * **Atomic Apply + Call:** A new EVM method ApplyAndCall processes authorization tuples and immediately executes the outer call atomically.
  * **Interpreter Semantics:** The EVM interpreter handles delegation at CALL‑to‑EOA time, executing the delegate’s bytecode under the authority’s context; EXTCODE* opcodes expose a short pointer code on the authority account.
  * **Client Handling (Lotus):** Lotus exposes the `0x04` typed transaction, parses it, and constructs a Filecoin message invoking EVM.ApplyAndCall with atomic CBOR params.
  * **Mempool:** No 7702‑specific ingress policies; standard nonce/fee rules apply.

This design keeps Ethereum semantics where transactions update account behavior, making those updates visible and enforceable on-chain for subsequent EVM execution.

-----

## 1\. Architectural Overview

The implementation involves coordinated changes across the stack, centered on the EVM actor.

```
                       ┌──────────────────────────────┐
                       │ Lotus (Go)                   │
                       │ • Parses 0x04 tx             │
eth_sendRawTransaction │ • Encodes CBOR params        │  Mempool
   (JSON-RPC) ───────▶ │ • Builds msg → EVM.ApplyAndCall │
                       │ • RPC views/receipts         │
                       └───────────────┬──────────────┘
                                       │ Filecoin message (ApplyAndCall)
                                       ▼
              ┌─────────────────────────────────────────────┐
              │ EVM Actor — Rust/FVM                        │
              │ • ApplyAndCall (verify, write, bump, exec)  │
              │ • State: delegations (EOA→{delegate,nonce}) │
              │   - Atomic apply+call (rollback on revert)  │
              │ • CALL interception                         │
              │   - If delegated: execute delegate under    │
              │     authority context (no cross‑actor hop)  │
              │ • EXTCODE*/pointer code semantics           │
              │ • Event emission                            │
              └─────────────────────────────────────────────┘
```

### Activation & Flags

  * **Network Version Gate:** EIP-7702 functionality is gated by a specific network version (e.g., `NV_EIP_7702`).
  * **Lotus Feature Flag:** The send‑path is controlled by the `eip7702_enabled` build tag for development/testing.

-----

## 2\. On-Chain Logic (Rust/FVM)

### 2.1 EVM Actor (EVM‑Only)

The EVM actor persists all EIP‑7702 state and enforces tuple validation, nonce tracking, and execution semantics.

#### State Structure

Recommended state:

1.  **`delegations`**: Map Authority (EOA `EthAddress`) → `{ delegate: EthAddress, nonce: u64 }`.
2.  (Optional) **authority storage roots** if isolating per‑EOA storage; otherwise reuse standard account storage.

#### Core Methods

  * **`ApplyAndCall` (New method):** Entry point for `0x04` transactions.
      * **Validates:** `chain_id ∈ {0, local}`, `y_parity ∈ {0,1}`, non‑zero `r/s`, **low‑s**.
      * **Recovers Authority:** `keccak256(0x05 || rlp([chain_id, address, nonce]))` then secp256k1 recovery.
      * **Verifies Nonce:** Matches the stored per‑authority delegation nonce.
      * **Updates State:** Update `delegations` and bump nonce(s).
      * **Executes:** Executes the outer call atomically; on revert, roll back the mapping/nonces.

> **Why this design?** On-chain state ensures consensus on delegations. Nonces prevent replay attacks. Separate storage roots per EOA allow delegation with strong, account-local semantics, isolating the EOA’s storage from the delegate’s contract state.

### 2.2 Interpreter Changes

#### A. CALL Path: Interception and Delegation

The EVM interpreter's `CALL` instruction logic is modified:

1.  **EOA Detection:** The interpreter checks if the call target is an EOA and if EIP-7702 is active.
2.  **Delegation Resolution:** Consult the EVM actor’s internal delegation map.
3.  **Delegation Activation:** If a delegate is found:
      * The runtime verifies the delegate is an EVM contract and loads its bytecode CID.
      * **Value Transfer:** For non-static calls, any value attached is first transferred to the EOA (Authority).
      * **Event Emission:** Emit `EIP7702Delegated(address)` for observability.
      * **Execution:** Execute the delegate code under the authority context (no cross‑actor trampoline required).
4.  **No-Code Behavior:** If the delegate exists but has no bytecode or is non-EVM, the call resolves as a no-op success (`1`), mirroring standard EOA call behavior.

(If employing per‑EOA storage isolation, the interpreter should mount/unmount the authority storage root internally during delegated execution.)
4.  **Storage Persistence:** After execution, if not read-only, the interpreter flushes the storage (`system.flush_storage_root`). `InvokeAsEoa` then calls `Delegator.PutStorageRoot` to save the new CID back to the Delegator actor.

> **Why this design?** The mount/flush mechanism provides EOA-scoped storage longevity across different delegate contracts and messages, while allowing the delegate's code to run unmodified within the EOA's context.

-----

## 3\. Client Logic (Go/Lotus)

### 3.1 Parsing 0x04 Transactions

Lotus (`ethtypes`) recognizes the `0x04` prefix and decodes the RLP payload.

  * **Outer Envelope:** Includes standard EIP-1559 fields, the new `authorizationList`, and the outer signature (`v`, `r`, `s`).
  * **`authorizationList`**: A list of 6-tuples: `[chain_id, address(20 bytes), nonce, y_parity, r (bytes), s (bytes)]`.

### 3.2 Conversion to Filecoin Message

The `ToUnsignedFilecoinMessage` method converts the parsed `Eth7702TxArgs` structure into a single Filecoin message. This is gated by the `eip7702_enabled` build tag.

  * `To`: The Delegator Actor (ID 18).
  * `Method`: `ApplyAndCall`.
  * `Params`: Atomic CBOR `[ [ tuple1, tuple2, ... ], [ to(20), value, input ] ]`.

### 3.3 Mempool

EIP-7702 transactions are admitted under the standard mempool rules (nonce, fee, size constraints). Lotus does not implement 7702-specific ingress-time policies such as cross-account eviction or per-sender delegation caps.

### 3.4 RPC Surfaces and Gas Estimation

#### Gas Estimation

`EthEstimateGas` is updated to account for EIP-7702 overhead. When estimating a message targeting ApplyAndCall, Lotus parses the CBOR parameters to count the authorization tuples and adds intrinsic overhead (behavioral only until constants finalize).

#### RPC Responses and Receipts

To provide compatibility with Ethereum tooling, the `EthTx` and `EthTxReceipt` structures are extended:

1.  **`AuthorizationList`**: Included in both the transaction object and the receipt if the transaction type was `0x04`.
2.  **`DelegatedTo`**: A new field added to the receipt to indicate which contracts were involved. Lotus populates this by extracting addresses from the `AuthorizationList` or by scanning execution logs for the `EIP7702Delegated(address)` event emitted by the FVM.

-----

## 4\. End-to-End Flows

### 4.1 Applying Delegations (Type 0x04 Tx)

1.  **Client Submission:** An RPC client submits a `0x04` transaction.
2.  **Lotus Parsing/Conversion:** Lotus parses the tx and builds a Filecoin message targeting `EVM.ApplyAndCall`.
3.  The message enters the mempool under standard policies (no 7702-specific cap or cross-account invalidation on ingress).
4.  **FVM Execution (`ApplyAndCall`):** The EVM actor validates tuples, recovers authorities, verifies nonces, updates mappings, and executes the outer call atomically.

### 4.2 Calling a Delegated EOA

1.  **EVM CALL:** EVM code executes a `CALL` instruction targeting an EOA address.
2.  **Interception:** The EVM runtime intercepts the call and checks the EVM actor’s internal delegation map.
3.  **Delegation Found:** If a mapping exists:
    1.  Value is transferred to the EOA (Authority) if applicable.
    2.  The `EIP7702Delegated(address)` event is emitted.
    3.  The interpreter executes the delegate code under the authority context.
    5.  The result is returned to the original caller.

-----

## 5\. Security and Correctness

  * **Signature Validation:** The EVM actor strictly enforces the **low-s** requirement and rejects zero r/s values. Authority recovery relies on a standard `secp256k1` recovery process over the committed RLP data (0x05 domain), combined with stored delegation nonces for anti-replay.
  * **Storage Isolation:** If per‑EOA storage isolation is employed, the interpreter mounts/unmounts the authority storage internally during delegated execution.
  * **Reorgs:** Mempool invalidation is a best-effort policy upon ingress. Consensus correctness relies solely on the actor-enforced nonces and mappings at execution time.

-----

## 6\. Summary of Changes and Locations

This implementation required changes across the stack in the following key areas:

  * **EVM Internals (Rust):**
      * `actors/evm/*`: ApplyAndCall method, delegation state, CALL pointer semantics, EXTCODE* pointer behavior, optional storage mount.
  * **Runtime Wiring (Rust):**
      * Network version activation gate.
  * **Lotus (Go):**
      * `chain/types/ethtypes/eth_7702_transactions.go`: Added support for `0x04` RLP decoding and message construction.
      * `chain/types/ethtypes/eth_7702_params.go`: CBOR encoder for `authorizationList` matching actor ABI.
      * `chain/types/ethtypes/eth_types.go`: Extended RPC types/receipts to expose `authorizationList` and `DelegatedTo`.

-----

## Appendices: Technical Specifications

### A. Actor Method Numbers and Names

  * **EVM Actor:**
      * `ApplyAndCall` (public) — method number tbd.

### B. Encoding Boundaries

  * **RLP (Ethereum wire)**: `0x04` prefix followed by a 13-element list; `authorizationList` is a list of 6-tuples.
  * **CBOR (Actor ABI)**: `ApplyAndCall` parameters use atomic encoding `[ [ tuple... ], [ to(20), value, input ] ]`.
  * **Authority Recovery**: Digest = `keccak256(0x05 || rlp([chain_id, address(20), nonce]))`. Recovery uses FVM `recover_secp_public_key`.
