This document synthesizes the provided notes into a comprehensive overview and technical deep dive of the EIP-7702 implementation within the Filecoin network.

# Filecoin EVM + EIP-7702 (“Delegated EOAs”) — Implementation Overview

> **Audience:** Filecoin core developers, Lotus node operators, and technically-savvy contributors/auditors.
> **Scope:** This document details the integration of Ethereum’s **EIP-7702** into Filecoin’s EVM, synthesizing the architectural design and the interaction between the Go-based Lotus client and the Rust-based FVM (`builtin-actors`).

-----

## 0\. Understanding EIP-7702 in Filecoin

EIP-7702 introduces a mechanism allowing Externally Owned Accounts (EOAs) to temporarily adopt smart contract functionality. It lets an EOA delegate its execution context to a specified contract by publishing a signed **authorization tuple** via a new transaction type (`0x04`).

In this Filecoin integration, we implement the following architecture:

  * **Persist Delegations:** Delegation choices are stored on-chain in a new singleton system actor, the **Delegator Actor**, keyed by the authority (the EOA).
  * **EVM Execution Context Switching:** The EVM is modified to intercept calls to EOAs. If an active delegation exists, the EVM executes the delegate’s bytecode **within the EOA's context** (using the EOA's storage and balance).
  * **Client Handling (Lotus):** The Lotus client exposes the `0x04` transaction type via the Ethereum JSON-RPC. Lotus parses and validates these transactions, converting the authorization list into a Filecoin message directed at the Delegator actor.
  * **Mempool Policy:** New policies are implemented to handle cross-account state changes, ensuring pending messages from an authority are invalidated when that authority’s delegation (and thus its nonce) changes.

This design keeps Ethereum semantics where transactions update account behavior, making those updates visible and enforceable on-chain for subsequent EVM execution.

-----

## 1\. Architectural Overview

The implementation involves coordinated changes across the stack, centering around the new Delegator actor.

```
                       ┌──────────────────────────────┐
                       │ Lotus (Go)                   │
                       │ • Parses 0x04 tx             │
eth_sendRawTransaction │ • Encodes CBOR params        │  Mempool
   (JSON-RPC) ───────▶ │ • Builds msg → Delegator     │ ▶ policies (cap + eviction)
                       │ • RPC views/receipts         │
                       └───────────────┬──────────────┘
                                       │ Filecoin message (ApplyDelegations)
                                       ▼
              ┌─────────────────────────────────────────────┐
              │ Delegator Actor (ID 18) — Rust/FVM          │
              │ • ApplyDelegations (verify, write, bump)    │
              │ • LookupDelegate                            │
              │ • Get/PutStorageRoot                        │
              │ State (persistent):                         │
              │   - Mappings (Authority → Delegate)         │
              │   - Nonces (Per-Authority)                  │
              │   - Storage Roots (Per-Authority)           │
              └───────────────┬─────────────────────────────┘
                              │ during EVM CALL
                              ▼
              ┌─────────────────────────────────────────────┐
              │ EVM Actor/Runtime — Rust/FVM                │
              │ • CALL interception                         │
              │ • If delegated:                             │
              │   - InvokeAsEoa (trampoline)                │
              │   - Mount EOA storage root                  │
              │   - Run delegate code “as EOA”              │
              │   - Flush storage root                      │
              │ • Event emission                            │
              └─────────────────────────────────────────────┘
```

### Activation & Addresses

  * **Delegator Actor:** A new builtin singleton actor at **Actor ID 18** (address `f018`).
  * **Network Version Gate:** EIP-7702 functionality in actors is gated by a specific network version (e.g., `NV_EIP_7702`).
  * **Lotus Feature Flag:** The send-path functionality in Lotus is controlled by the `eip7702_enabled` build tag for development and testing. The Delegator address defaults to ID 18 but can be overridden via the `LOTUS_ETH_7702_DELEGATOR_ADDR` environment variable.

-----

## 2\. On-Chain Logic (Rust/FVM)

### 2.1 The Delegator Actor

The `Delegator` actor (`fil_actor_delegator`) is the cornerstone of the on-chain logic, serving as the authoritative registry for all EOA delegations, nonces, and storage.

#### State Structure

The actor maintains three primary Hash-Array Mapped Tries (HAMTs) in its state:

1.  **`mappings`**: Maps the Authority (EOA `EthAddress`) to the Delegate (Contract `EthAddress`).
2.  **`nonces`**: Tracks the delegation nonce (`u64`) for each Authority. This is distinct from the account transaction nonce and is used solely for EIP-7702 authorization replay protection.
3.  **`storage_roots`**: Maps the Authority to a `Cid`. This stores the root of the persistent EVM storage (KAMT) for the EOA, allowing EOAs to maintain their own state across different delegates.

#### Core Methods

  * **`ApplyDelegations` (Method 2):** The entry point for `0x04` transactions. It processes authorization tuples:
      * **Validates:** Checks `chain_id`, `y_parity`, non-zero `r`/`s`, and enforces the **low-s** requirement.
      * **Recovers Authority:** Computes the digest `keccak256(rlp([chain_id, delegate_address, nonce]))` and uses the FVM syscall `recover_secp_public_key` to recover the Authority's address.
      * **Verifies Nonce:** Checks the stored delegation nonce against the tuple's nonce.
      * **Updates State:** Updates the `mappings` and increments the authority's nonce.
  * **`LookupDelegate` (FRC-42):** Called by the EVM runtime during a `CALL` instruction to check for an active delegation.
  * **`GetStorageRoot` / `PutStorageRoot` (FRC-42):** Used by the EVM runtime to manage the EOA's persistent storage. Crucially, `PutStorageRoot` is permissioned and restricted to callers with the EVM actor code CID, ensuring storage integrity.

> **Why this design?** On-chain state ensures consensus on delegations. Nonces prevent replay attacks. Separate storage roots per EOA allow delegation with strong, account-local semantics, isolating the EOA’s storage from the delegate’s contract state.

### 2.2 EVM Actor Changes

The EVM implementation involves two critical modifications: the interception of `CALL` instructions and a new internal trampoline method to execute code within an EOA context.

#### A. CALL Path: Interception and Delegation

The EVM interpreter's `CALL` instruction logic is modified:

1.  **EOA Detection:** The interpreter checks if the call target is an EOA and if EIP-7702 is active.
2.  **Delegator Consultation:** The EVM calls `Delegator.LookupDelegate`.
3.  **Delegation Activation:** If a delegate is found:
      * The runtime verifies the delegate is an EVM contract and loads its bytecode CID.
      * **Value Transfer:** For non-static calls, any value attached is first transferred to the EOA (Authority).
      * **Event Emission:** An event `EIP7702Delegated(address)` is emitted for observability.
      * **Trampoline:** The execution flow is redirected via an internal self-call to the new `EVM.InvokeAsEoa` method.
4.  **No-Code Behavior:** If the delegate exists but has no bytecode or is non-EVM, the call resolves as a no-op success (`1`), mirroring standard EOA call behavior.

#### B. `InvokeAsEoa` (New Internal Method)

The new internal method `InvokeAsEoa` (Method 7) orchestrates the context switch and storage management. It is **only callable internally by the EVM actor itself**.

1.  **Storage Retrieval:** `InvokeAsEoa` calls `Delegator.GetStorageRoot` to fetch the EOA's storage CID.
2.  **Storage Mounting:** The EVM interpreter mounts this CID as the current storage root (`system.mount_storage_root`).
3.  **Execution:** The delegate's bytecode is executed. The execution context (`ADDRESS`) is the EOA, meaning `SLOAD`/`SSTORE` operate on the mounted EOA storage.
4.  **Storage Persistence:** After execution, if not read-only, the interpreter flushes the storage (`system.flush_storage_root`). `InvokeAsEoa` then calls `Delegator.PutStorageRoot` to save the new CID back to the Delegator actor.

> **Why this design?** The mount/flush mechanism provides EOA-scoped storage longevity across different delegate contracts and messages, while allowing the delegate's code to run unmodified within the EOA's context.

-----

## 3\. Client Logic (Go/Lotus)

### 3.1 Parsing 0x04 Transactions

Lotus (`ethtypes`) recognizes the `0x04` prefix and decodes the RLP payload.

  * **Outer Envelope:** Includes standard EIP-1559 fields, the new `authorizationList`, and the outer signature (`v`, `r`, `s`).
  * **`authorizationList`**: A list of 6-tuples: `[chain_id, address(20 bytes), nonce, y_parity, r (bytes), s (bytes)]`.

### 3.2 Conversion to Filecoin Message

The `ToUnsignedFilecoinMessage` method converts the parsed `Eth7702TxArgs` structure into a single Filecoin message. This is gated by the `eip7702_enabled` build tag.

  * `To`: The Delegator Actor (ID 18).
  * `Method`: `ApplyDelegations` (Method 2).
  * `Params`: The `authorizationList` is CBOR-encoded. The encoding uses a wrapper structure: `[ [ tuple1, tuple2, ... ] ]`.

> **Note:** In the initial implementation, the “call portion” (`to`, `input`, `value`) of the 0x04 transaction is **not** immediately executed. The `ApplyDelegations` message only updates the delegations. Any subsequent EVM CALL to that EOA will then use the new delegate.

### 3.3 Mempool Policies

EIP-7702 transactions affect the state (nonces) of accounts other than the sender (the authorities). This necessitates new mempool policies in Lotus, activated by the network version upgrade.

#### Cross-Account Invalidation

When an `ApplyDelegations` message enters the mempool:

1.  Lotus decodes the authorization tuples from the parameters.
2.  For each authority identified, Lotus inspects the authority’s pending messages.
3.  Because the execution will increment the authority's nonce, Lotus preemptively **evicts** any pending messages from that authority with a nonce less than or equal to the nonce specified in the tuple.
4.  An event (`"7702_evict"`) is journaled for observability.

#### Per-Sender Delegation Cap

To prevent spam, Lotus enforces a limit (default 4) on the number of pending `ApplyDelegations` messages from any single sender. If exceeded, the new message is rejected (`"7702_cap_reject"`).

### 3.4 RPC Surfaces and Gas Estimation

#### Gas Estimation

`EthEstimateGas` is updated to account for EIP-7702 overhead. When estimating a message targeting the Delegator, Lotus parses the CBOR parameters to count the authorization tuples and adds intrinsic overhead (`BaseOverheadGas` + `PerAuthBaseGas` per tuple). These constants must align with the authoritative costs charged by the FVM.

#### RPC Responses and Receipts

To provide compatibility with Ethereum tooling, the `EthTx` and `EthTxReceipt` structures are extended:

1.  **`AuthorizationList`**: Included in both the transaction object and the receipt if the transaction type was `0x04`.
2.  **`DelegatedTo`**: A new field added to the receipt to indicate which contracts were involved. Lotus populates this by extracting addresses from the `AuthorizationList` or by scanning execution logs for the `EIP7702Delegated(address)` event emitted by the FVM.

-----

## 4\. End-to-End Flows

### 4.1 Applying Delegations (Type 0x04 Tx)

1.  **Client Submission:** An RPC client submits a `0x04` transaction.
2.  **Lotus Parsing/Conversion:** Lotus parses the tx and builds a Filecoin message targeting `Delegator.ApplyDelegations`.
3.  **Mempool Policies:** The message enters the mempool. Cross-account invalidation occurs, and the per-sender cap is enforced.
4.  **FVM Execution (`ApplyDelegations`):** When mined, the Delegator actor validates tuples, recovers authorities, verifies nonces, updates mappings, and increments the nonces.

### 4.2 Calling a Delegated EOA

1.  **EVM CALL:** EVM code executes a `CALL` instruction targeting an EOA address.
2.  **Interception:** The EVM runtime intercepts the call and checks the Delegator actor for a mapping.
3.  **Delegation Found:** If a mapping exists:
    1.  Value is transferred to the EOA (Authority) if applicable.
    2.  The `EIP7702Delegated(address)` event is emitted.
    3.  The runtime trampolines to `InvokeAsEoa`.
    4.  `InvokeAsEoa` mounts the EOA’s storage root, executes the delegate’s code as the EOA, and flushes the storage root back to the Delegator.
    5.  The result is returned to the original caller.

-----

## 5\. Security and Correctness

  * **Signature Validation:** The Delegator actor strictly enforces the **low-s** requirement and rejects zero r/s values. Authority recovery relies on a standard `secp256k1` recovery process over the committed RLP data, combined with actor-stored nonce checks for anti-replay.
  * **Storage Isolation:** Authority storage is maintained in a **per-EOA storage root**, managed by the Delegator actor. This prevents delegates from accessing or corrupting each other's state, ensuring predictable "EOA-as-contract" behavior.
  * **Restricted Methods:** The `InvokeAsEoa` method is restricted to internal calls by the EVM actor. `PutStorageRoot` is restricted to callers with the EVM actor code CID.
  * **Reorgs:** Mempool invalidation is a best-effort policy upon ingress. Consensus correctness relies solely on the actor-enforced nonces and mappings at execution time.

-----

## 6\. Summary of Changes and Locations

This implementation required changes across the stack in the following key areas:

  * **New Builtin Actor (Rust):**
      * `actors/delegator/*`: Manages mappings, nonces, and storage roots. Implements `ApplyDelegations`, `LookupDelegate`, `Get/PutStorageRoot`.
  * **EVM Internals (Rust):**
      * `actors/evm/src/interpreter/instructions/call.rs`: Modified `CALL` path to consult Delegator for EOA targets.
      * `actors/evm/src/lib.rs`: New `InvokeAsEoa` (Method 7) internal trampoline method.
      * `System` runtime gained `mount_storage_root` and `flush_storage_root` capabilities.
  * **Runtime Wiring (Rust):**
      * Defined `DELEGATOR_ACTOR_ID = 18` and network version activation gate.
  * **Lotus (Go):**
      * `chain/types/ethtypes/eth_7702_transactions.go`: Added support for `0x04` RLP decoding and message construction.
      * `chain/types/ethtypes/eth_7702_params.go`: CBOR encoder for `authorizationList` matching actor ABI.
      * `chain/messagepool/messagepool.go`: Implemented cross-account eviction and the per-sender delegation cap.
      * `chain/types/ethtypes/eth_types.go`: Extended RPC types/receipts to expose `authorizationList` and `DelegatedTo`.

-----

## Appendices: Technical Specifications

### A. Actor Method Numbers and Names

  * **Delegator Actor (ID 18):**
      * `Constructor = 1`
      * `ApplyDelegations = 2`
      * `LookupDelegate = frc42("LookupDelegate")`
      * `GetStorageRoot = frc42("GetStorageRoot")`
      * `PutStorageRoot = frc42("PutStorageRoot")`
  * **EVM Actor:**
      * `InvokeAsEoa = 7` (Internal)

### B. Encoding Boundaries

  * **RLP (Ethereum wire)**: `0x04` prefix followed by a 13-element list; `authorizationList` is a list of 6-tuples.
  * **CBOR (Actor ABI)**: `ApplyDelegations` parameters are encoded as a wrapper list containing the list of 6-tuples.
  * **Authority Recovery**: Digest = `keccak256(rlp([chain_id, address(20), nonce]))`. Recovery uses FVM `recover_secp_public_key`.
