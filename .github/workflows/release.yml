name: Release

on:
  push:
    branches:
      - release/v*
      - release/miner/v*
      - releases
    paths:
      - build/version.go
  pull_request:
    branches:
      - release/v*
      - release/miner/v*
      - releases
    paths:
      - build/version.go
  workflow_dispatch:
    inputs:
      projects:
        description: 'Projects to release (JSON array)'
        required: false
        default: '[]'
      ref:
        description: 'Ref to buuild the binaries from'
        required: false
        default: ''
      publish:
        description: 'Publish the release'
        required: false
        default: 'false'

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  check:
    name: Check which projects need to be released
    runs-on: ubuntu-latest
    outputs:
      projects: ${{ steps.projects.outputs.projects }}
    steps:
      - name: Check out lotus
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.ref }}
      - name: Find projects that need to be released
        id: projects
        env:
          projects: ${{ github.event.inputs.projects }}
        run: |
          go run cmd/release/main.go --json list-projects | jq -r '.msg' |
            jq 'map(select(.version | endswith("-dev") | not))' |
            jq 'map(select(.released | not))' |
            jq 'map(select(
              (env.GITHUB_EVENT_NAME == "push" and ((env.GITHUB_REF == "refs/heads/releases" and .prerelease == false) or (env.GITHUB_REF != "refs/heads/releases" and .prerelease == true))) or
              (env.GITHUB_EVENT_NAME == "pull_request" and ((env.GITHUB_BASE_REF == "releases" and .prerelease == false) or (env.GITHUB_BASE_REF != "releases" and .prerelease == true))) or
              (env.GITHUB_EVENT_NAME == "workflow_dispatch" and (.name as $name | env.projects | fromjson | index($name) != null))
            ))' |
            jq -c '.' | xargs -I {} -0 echo "projects={}" |
            tee -a $GITHUB_OUTPUT
  build:
    needs: [check]
    if: needs.check.outputs.projects != '[]'
    name: Build ${{ matrix.project }} (${{ matrix.runner }})
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJSON(needs.check.outputs.projects).*.name }}
        runner:
          - ubuntu-latest # Linux X64
          - macos-13 # MacOs X64
          - macos-14 # MacOS ARM64
    steps:
      - name: Print runner information
        run: echo "Building on $RUNNER_OS/$RUNNER_ARCH"
      - name: Make project config available
        id: project
        env:
          projects: ${{ needs.check.outputs.projects }}
          name: ${{ matrix.project }}
        run: |
          jq -nc 'env.projects | fromjson | map(select(.name == env.name)) | .[0]' |
            xargs -I {} -0 echo "config={}" |
            tee -a $GITHUB_OUTPUT
      - name: Check out lotus
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      - name: Install system dependencies
        uses: ./.github/actions/install-system-dependencies
      - name: Install Go
        uses: ./.github/actions/install-go
      - if: github.event.inputs.ref
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          ref: ${{ github.event.inputs.ref }}
      - name: Build binaries
        env:
          GITHUB_TOKEN: ${{ github.token }}
          binaries: ${{ toJSON(fromJSON(steps.project.outputs.config).binaries) }}
        run: |
          make deps
          while read -r binary; do
            if [[ -z "$binary" ]]; then
              continue
            fi
            make $binary
          done <<< "$(jq -r '.[]' <<< "$binaries")"
      - name: Run otool
        if: runner.os == 'macOS'
        run: if [[ -f lotus ]]; then otool -hv lotus; fi
      - name: Verify binary versions
        env:
          LOTUS_VERSION_IGNORE_COMMIT: 1
          expected: ${{ fromJSON(steps.project.outputs.config).version }}
        run: |
          for bin in lotus lotus-miner lotus-worker; do
            if [[ -f ./$bin ]]; then
              chmod +x ./$bin
              actual=$(./$bin --version | cut -d' ' -f3)
              if [[ "$actual" != "$expected" ]]; then
                echo "::error title=Version Mismatch::Expected $expected, got $actual (./$bin)"
                exit 1
              fi
            fi
          done
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lotus-${{ matrix.project }}-${{ runner.os }}-${{ runner.arch }}
          path: |
            lotus
            lotus-miner
            lotus-worker
  release:
    needs: [check, build]
    if: needs.check.outputs.projects != '[]'
    name: Release ${{ matrix.project }}
    permissions:
      # This enables the job to create and/or update GitHub releases
      contents: write
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJSON(needs.check.outputs.projects).*.name }}
    steps:
      - name: Make project config available
        id: project
        env:
          projects: ${{ needs.check.outputs.projects }}
          name: ${{ matrix.project }}
        run: |
          jq -nc 'env.projects | fromjson | map(select(.name == env.name)) | .[0]' |
            xargs -I {} -0 echo "config={}" |
            tee -a $GITHUB_OUTPUT
      - name: Check out lotus
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          fetch-depth: 0
      - name: Download Linux X64 binaries
        uses: actions/download-artifact@v4
        with:
          name: lotus-${{ matrix.project }}-Linux-X64
          path: linux_amd64_v1
      - name: Download macOS X64 binaries
        uses: actions/download-artifact@v4
        with:
          name: lotus-${{ matrix.project }}-macOS-X64
          path: darwin_amd64_v1
      - name: Download macOS ARM64 binaries
        uses: actions/download-artifact@v4
        with:
          name: lotus-${{ matrix.project }}-macOS-ARM64
          path: darwin_arm64
      - name: Install Go (archives generation dependency)
        uses: ./.github/actions/install-go
      - name: Generate archives
        env:
          prefix: ${{ matrix.project == 'node' && 'lotus' || format('lotus-{0}', matrix.project) }}
          version: ${{ fromJSON(steps.project.outputs.config).version }}
          binaries: ${{ toJSON(fromJSON(steps.project.outputs.config).binaries) }}
        run: |
          mkdir darwin_all
          while read -r binary; do
            if [[ -z "$binary" ]]; then
              continue
            fi
            go run github.com/randall77/makefat ./darwin_all/$binary ./darwin_amd64_v1/$binary ./darwin_arm64/$binary
          done <<< "$(jq -r '.[]' <<< "$binaries")"
          mkdir dist
          pushd dist
          for directory in darwin_all linux_amd64_v1; do
            cp -r ../$directory $prefix_v$version_$directory
            tar -czf $prefix_v$version_$directory.tar.gz $directory
            rm -r $prefix_v$version_$directory
          done
          popd
      - name: Install Kubo (checksums generation dependency)
        uses: ipfs/download-ipfs-distribution-action@v1
        with:
          name: kubo
          version: v0.16.0
          cache: false
      - name: Generate checksums
        run: ./scripts/generate-checksums.sh
      - name: Install zsh (changelog generation dependency)
        run: sudo apt update && sudo apt install -y zsh
      - name: Generate changelog
        id: changelog
        env:
          tag: ${{ fromJSON(steps.project.outputs.config).tag }}
          previous: ${{ fromJSON(steps.project.outputs.config).previous }}
          current: ${{ github.event.inputs.ref || github.sha }}
        run: |
          echo "content<<EOF" | tee -a $GITHUB_OUTPUT
          echo "# $tag" | tee -a $GITHUB_OUTPUT
          echo "" | tee -a $GITHUB_OUTPUT
          csplit --digits=4 --quiet --elide-empty-files CHANGELOG.md '/^# /' '{*}'
          # Checking the files in reverse order to get to the UNRELEASED section last
          for file in $(ls -r xx*); do
            if grep -q "^# $tag " $file || grep -q "^# UNRELEASED" $file; then
              tail -n +3 $file | tee -a $GITHUB_OUTPUT
              break
            fi
          done
          if [[ "$previous" != '' ]]; then
            mkdir -p "$(go env GOPATH)/src/github.com/$GITHUB_REPOSITORY"
            rm -rf "$(go env GOPATH)/src/github.com/$GITHUB_REPOSITORY"
            ln -s "$(pwd)" "$(go env GOPATH)/src/github.com/$GITHUB_REPOSITORY"
            ./scripts/mkreleaselog "$previous" "$current" | tee -a $GITHUB_OUTPUT
          fi
          echo "EOF" | tee -a $GITHUB_OUTPUT
      - name: Find release
        id: before
        env:
          tag: ${{ fromJSON(steps.project.outputs.config).tag }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "release>>EOF" | tee -a $GITHUB_OUTPUT
          gh api --paginate /repos/$GITHUB_REPOSITORY/releases --jq 'map(select(.tag_name == env.tag))' |
            jq -s add | jq -r '.[0]' | tee -a $GITHUB_OUTPUT
          echo "EOF" | tee -a $GITHUB_OUTPUT
      - name: Create or update release
        id: after
        env:
          method: ${{ steps.before.outputs.release == 'null' && 'POST' || 'PATCH' }}
          endpoint: ${{ steps.before.outputs.release == 'null' && format('/repos/{0}/releases', github.repository) || format('/repos/{0}/releases/{1}', github.repository, fromJSON(steps.before.outputs.release).id) }}
          tag_name: ${{ fromJSON(steps.project.outputs.config).tag }}
          target_commitish: ${{ github.event.inputs.ref || github.base_ref || github.ref }}
          name: ${{ fromJSON(steps.project.outputs.config).tag }}
          body: ${{ steps.changelog.outputs.content }}
          draft: ${{ steps.before.outputs.release == 'null' && true || fromJSON(steps.before.outputs.release).draft }}
          prerelease: ${{ fromJSON(steps.project.outputs.config).prerelease }}
          make_latest: ${{ fromJSON(steps.project.outputs.config).latest }}
          discussion_category_name: ""
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "release>>EOF" | tee -a $GITHUB_OUTPUT
          gh api -X "$method" "$endpoint" \
            --field tag_name="$tag_name" \
            --field target_commitish="$target_commitish" \
            --field name="$name" \
            --field body="$body" \
            --field draft=$draft \
            --field prerelease=$prerelease \
            --field make_latest=$make_latest \
            --field discussion_category_name="$discussion_category_name" |
            tee -a $GITHUB_OUTPUT
          echo "EOF" | tee -a $GITHUB_OUTPUT
      - name: Delete old assets
        env:
          asset_ids: ${{ toJSON(fromJSON(steps.after.outputs.release).assets.*.id) }}
          release_id: ${{ fromJSON(steps.after.outputs.release).id }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          while read -r asset_id; do
            gh api -X DELETE /repos/$GITHUB_REPOSITORY/releases/$release_id/assets/$asset_id
          done <<< "$(jq '.[]' <<< "$asset_ids")"
      - name: Upload new assets
        env:
          release_id: ${{ fromJSON(steps.after.outputs.release).id }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          for asset in *.{tar.gz,cid,sha512}; do
            gh api -X POST /repos/$GITHUB_REPOSITORY/releases/$release_id/assets?name=$asset \
              --field "@$asset" |
              jq -r '.id'
          done
      - name: Publish release
        if: github.event.inputs.publish == 'true' || github.event_name == 'push'
        env:
          release_id: ${{ fromJSON(steps.after.outputs.release).id }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          gh api -X PATCH /repos/$GITHUB_REPOSITORY/releases/$release_id \
            --field draft=false
