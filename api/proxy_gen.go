// Code generated by github.com/filecoin-project/lotus/gen/api. DO NOT EDIT.

package api

import (
	"context"
	"time"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-bitfield"
	datatransfer "github.com/filecoin-project/go-data-transfer"
	"github.com/filecoin-project/go-fil-markets/piecestore"
	"github.com/filecoin-project/go-fil-markets/retrievalmarket"
	"github.com/filecoin-project/go-fil-markets/storagemarket"
	"github.com/filecoin-project/go-jsonrpc/auth"
	"github.com/filecoin-project/go-multistore"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/go-state-types/dline"
	apitypes "github.com/filecoin-project/lotus/api/types"
	"github.com/filecoin-project/lotus/chain/actors/builtin"
	"github.com/filecoin-project/lotus/chain/actors/builtin/miner"
	"github.com/filecoin-project/lotus/chain/actors/builtin/paych"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/filecoin-project/lotus/extern/sector-storage/fsutil"
	"github.com/filecoin-project/lotus/extern/sector-storage/sealtasks"
	"github.com/filecoin-project/lotus/extern/sector-storage/stores"
	"github.com/filecoin-project/lotus/extern/sector-storage/storiface"
	"github.com/filecoin-project/lotus/extern/storage-sealing/sealiface"
	marketevents "github.com/filecoin-project/lotus/markets/loggers"
	"github.com/filecoin-project/lotus/node/modules/dtypes"
	"github.com/filecoin-project/specs-storage/storage"
	"github.com/google/uuid"
	"github.com/ipfs/go-cid"
	metrics "github.com/libp2p/go-libp2p-core/metrics"
	"github.com/libp2p/go-libp2p-core/network"
	"github.com/libp2p/go-libp2p-core/peer"
	protocol "github.com/libp2p/go-libp2p-core/protocol"
	xerrors "golang.org/x/xerrors"
)

type ChainIOStruct struct {
	Internal struct {
		ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) ``

		ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) ``
	}
}

type ChainIOStub struct {
}

type CommonStruct struct {
	Internal struct {
		AuthNew func(p0 context.Context, p1 []auth.Permission) ([]byte, error) `perm:"admin"`

		AuthVerify func(p0 context.Context, p1 string) ([]auth.Permission, error) `perm:"read"`

		Closing func(p0 context.Context) (<-chan struct{}, error) `perm:"read"`

		Discover func(p0 context.Context) (apitypes.OpenRPCDocument, error) `perm:"read"`

		ID func(p0 context.Context) (peer.ID, error) `perm:"read"`

		LogList func(p0 context.Context) ([]string, error) `perm:"write"`

		LogSetLevel func(p0 context.Context, p1 string, p2 string) error `perm:"write"`

		NetAddrsListen func(p0 context.Context) (peer.AddrInfo, error) `perm:"read"`

		NetAgentVersion func(p0 context.Context, p1 peer.ID) (string, error) `perm:"read"`

		NetAutoNatStatus func(p0 context.Context) (NatInfo, error) `perm:"read"`

		NetBandwidthStats func(p0 context.Context) (metrics.Stats, error) `perm:"read"`

		NetBandwidthStatsByPeer func(p0 context.Context) (map[string]metrics.Stats, error) `perm:"read"`

		NetBandwidthStatsByProtocol func(p0 context.Context) (map[protocol.ID]metrics.Stats, error) `perm:"read"`

		NetBlockAdd func(p0 context.Context, p1 NetBlockList) error `perm:"admin"`

		NetBlockList func(p0 context.Context) (NetBlockList, error) `perm:"read"`

		NetBlockRemove func(p0 context.Context, p1 NetBlockList) error `perm:"admin"`

		NetConnect func(p0 context.Context, p1 peer.AddrInfo) error `perm:"write"`

		NetConnectedness func(p0 context.Context, p1 peer.ID) (network.Connectedness, error) `perm:"read"`

		NetDisconnect func(p0 context.Context, p1 peer.ID) error `perm:"write"`

		NetFindPeer func(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) `perm:"read"`

		NetPeerInfo func(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) `perm:"read"`

		NetPeers func(p0 context.Context) ([]peer.AddrInfo, error) `perm:"read"`

		NetPubsubScores func(p0 context.Context) ([]PubsubScore, error) `perm:"read"`

		Session func(p0 context.Context) (uuid.UUID, error) `perm:"read"`

		Shutdown func(p0 context.Context) error `perm:"admin"`

		Version func(p0 context.Context) (APIVersion, error) `perm:"read"`
	}
}

type CommonStub struct {
}

type FullNodeStruct struct {
	CommonStruct

	Internal struct {
		BeaconGetEntry func(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) `perm:"read"`

		ChainDeleteObj func(p0 context.Context, p1 cid.Cid) error `perm:"admin"`

		ChainExport func(p0 context.Context, p1 abi.ChainEpoch, p2 bool, p3 types.TipSetKey) (<-chan []byte, error) `perm:"read"`

		ChainGetBlock func(p0 context.Context, p1 cid.Cid) (*types.BlockHeader, error) `perm:"read"`

		ChainGetBlockMessages func(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) `perm:"read"`

		ChainGetGenesis func(p0 context.Context) (*types.TipSet, error) `perm:"read"`

		ChainGetMessage func(p0 context.Context, p1 cid.Cid) (*types.Message, error) `perm:"read"`

		ChainGetNode func(p0 context.Context, p1 string) (*IpldObject, error) `perm:"read"`

		ChainGetParentMessages func(p0 context.Context, p1 cid.Cid) ([]Message, error) `perm:"read"`

		ChainGetParentReceipts func(p0 context.Context, p1 cid.Cid) ([]*types.MessageReceipt, error) `perm:"read"`

		ChainGetPath func(p0 context.Context, p1 types.TipSetKey, p2 types.TipSetKey) ([]*HeadChange, error) `perm:"read"`

		ChainGetRandomnessFromBeacon func(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) `perm:"read"`

		ChainGetRandomnessFromTickets func(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) `perm:"read"`

		ChainGetTipSet func(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) `perm:"read"`

		ChainGetTipSetByHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) `perm:"read"`

		ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) `perm:"read"`

		ChainHead func(p0 context.Context) (*types.TipSet, error) `perm:"read"`

		ChainNotify func(p0 context.Context) (<-chan []*HeadChange, error) `perm:"read"`

		ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) `perm:"read"`

		ChainSetHead func(p0 context.Context, p1 types.TipSetKey) error `perm:"admin"`

		ChainStatObj func(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (ObjStat, error) `perm:"read"`

		ChainTipSetWeight func(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		ClientCalcCommP func(p0 context.Context, p1 string) (*CommPRet, error) `perm:"write"`

		ClientCancelDataTransfer func(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error `perm:"write"`

		ClientCancelRetrievalDeal func(p0 context.Context, p1 retrievalmarket.DealID) error `perm:"write"`

		ClientDataTransferUpdates func(p0 context.Context) (<-chan DataTransferChannel, error) `perm:"write"`

		ClientDealPieceCID func(p0 context.Context, p1 cid.Cid) (DataCIDSize, error) `perm:"read"`

		ClientDealSize func(p0 context.Context, p1 cid.Cid) (DataSize, error) `perm:"read"`

		ClientFindData func(p0 context.Context, p1 cid.Cid, p2 *cid.Cid) ([]QueryOffer, error) `perm:"read"`

		ClientGenCar func(p0 context.Context, p1 FileRef, p2 string) error `perm:"write"`

		ClientGetDealInfo func(p0 context.Context, p1 cid.Cid) (*DealInfo, error) `perm:"read"`

		ClientGetDealStatus func(p0 context.Context, p1 uint64) (string, error) `perm:"read"`

		ClientGetDealUpdates func(p0 context.Context) (<-chan DealInfo, error) `perm:"write"`

		ClientGetRetrievalUpdates func(p0 context.Context) (<-chan RetrievalInfo, error) `perm:"write"`

		ClientHasLocal func(p0 context.Context, p1 cid.Cid) (bool, error) `perm:"write"`

		ClientImport func(p0 context.Context, p1 FileRef) (*ImportRes, error) `perm:"admin"`

		ClientListDataTransfers func(p0 context.Context) ([]DataTransferChannel, error) `perm:"write"`

		ClientListDeals func(p0 context.Context) ([]DealInfo, error) `perm:"write"`

		ClientListImports func(p0 context.Context) ([]Import, error) `perm:"write"`

		ClientListRetrievals func(p0 context.Context) ([]RetrievalInfo, error) `perm:"write"`

		ClientMinerQueryOffer func(p0 context.Context, p1 address.Address, p2 cid.Cid, p3 *cid.Cid) (QueryOffer, error) `perm:"read"`

		ClientQueryAsk func(p0 context.Context, p1 peer.ID, p2 address.Address) (*storagemarket.StorageAsk, error) `perm:"read"`

		ClientRemoveImport func(p0 context.Context, p1 multistore.StoreID) error `perm:"admin"`

		ClientRestartDataTransfer func(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error `perm:"write"`

		ClientRetrieve func(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) error `perm:"admin"`

		ClientRetrieveTryRestartInsufficientFunds func(p0 context.Context, p1 address.Address) error `perm:"write"`

		ClientRetrieveWithEvents func(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) (<-chan marketevents.RetrievalEvent, error) `perm:"admin"`

		ClientStartDeal func(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) `perm:"admin"`

		ClientStatelessDeal func(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) `perm:"write"`

		CreateBackup func(p0 context.Context, p1 string) error `perm:"admin"`

		GasEstimateFeeCap func(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		GasEstimateGasLimit func(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (int64, error) `perm:"read"`

		GasEstimateGasPremium func(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		GasEstimateMessageGas func(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) `perm:"read"`

		MarketAddBalance func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) `perm:"sign"`

		MarketGetReserved func(p0 context.Context, p1 address.Address) (types.BigInt, error) `perm:"sign"`

		MarketReleaseFunds func(p0 context.Context, p1 address.Address, p2 types.BigInt) error `perm:"sign"`

		MarketReserveFunds func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) `perm:"sign"`

		MarketWithdraw func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) `perm:"sign"`

		MinerCreateBlock func(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) `perm:"write"`

		MinerGetBaseInfo func(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) `perm:"read"`

		MpoolBatchPush func(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) `perm:"write"`

		MpoolBatchPushMessage func(p0 context.Context, p1 []*types.Message, p2 *MessageSendSpec) ([]*types.SignedMessage, error) `perm:"sign"`

		MpoolBatchPushUntrusted func(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) `perm:"write"`

		MpoolCheckMessages func(p0 context.Context, p1 []*MessagePrototype) ([][]MessageCheckStatus, error) `perm:"read"`

		MpoolCheckPendingMessages func(p0 context.Context, p1 address.Address) ([][]MessageCheckStatus, error) `perm:"read"`

		MpoolCheckReplaceMessages func(p0 context.Context, p1 []*types.Message) ([][]MessageCheckStatus, error) `perm:"read"`

		MpoolClear func(p0 context.Context, p1 bool) error `perm:"write"`

		MpoolGetConfig func(p0 context.Context) (*types.MpoolConfig, error) `perm:"read"`

		MpoolGetNonce func(p0 context.Context, p1 address.Address) (uint64, error) `perm:"read"`

		MpoolPending func(p0 context.Context, p1 types.TipSetKey) ([]*types.SignedMessage, error) `perm:"read"`

		MpoolPush func(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) `perm:"write"`

		MpoolPushMessage func(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) `perm:"sign"`

		MpoolPushUntrusted func(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) `perm:"write"`

		MpoolSelect func(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) `perm:"read"`

		MpoolSetConfig func(p0 context.Context, p1 *types.MpoolConfig) error `perm:"admin"`

		MpoolSub func(p0 context.Context) (<-chan MpoolUpdate, error) `perm:"read"`

		MsigAddApprove func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 bool) (*MessagePrototype, error) `perm:"sign"`

		MsigAddCancel func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 bool) (*MessagePrototype, error) `perm:"sign"`

		MsigAddPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) `perm:"sign"`

		MsigApprove func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address) (*MessagePrototype, error) `perm:"sign"`

		MsigApproveTxnHash func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 address.Address, p5 types.BigInt, p6 address.Address, p7 uint64, p8 []byte) (*MessagePrototype, error) `perm:"sign"`

		MsigCancel func(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 types.BigInt, p5 address.Address, p6 uint64, p7 []byte) (*MessagePrototype, error) `perm:"sign"`

		MsigCreate func(p0 context.Context, p1 uint64, p2 []address.Address, p3 abi.ChainEpoch, p4 types.BigInt, p5 address.Address, p6 types.BigInt) (*MessagePrototype, error) `perm:"sign"`

		MsigGetAvailableBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		MsigGetPending func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) `perm:"read"`

		MsigGetVested func(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		MsigGetVestingSchedule func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MsigVesting, error) `perm:"read"`

		MsigPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt, p4 address.Address, p5 uint64, p6 []byte) (*MessagePrototype, error) `perm:"sign"`

		MsigRemoveSigner func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) `perm:"sign"`

		MsigSwapApprove func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 address.Address) (*MessagePrototype, error) `perm:"sign"`

		MsigSwapCancel func(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address) (*MessagePrototype, error) `perm:"sign"`

		MsigSwapPropose func(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 address.Address) (*MessagePrototype, error) `perm:"sign"`

		NodeStatus func(p0 context.Context, p1 bool) (NodeStatus, error) `perm:"read"`

		PaychAllocateLane func(p0 context.Context, p1 address.Address) (uint64, error) `perm:"sign"`

		PaychAvailableFunds func(p0 context.Context, p1 address.Address) (*ChannelAvailableFunds, error) `perm:"sign"`

		PaychAvailableFundsByFromTo func(p0 context.Context, p1 address.Address, p2 address.Address) (*ChannelAvailableFunds, error) `perm:"sign"`

		PaychCollect func(p0 context.Context, p1 address.Address) (cid.Cid, error) `perm:"sign"`

		PaychGet func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (*ChannelInfo, error) `perm:"sign"`

		PaychGetWaitReady func(p0 context.Context, p1 cid.Cid) (address.Address, error) `perm:"sign"`

		PaychList func(p0 context.Context) ([]address.Address, error) `perm:"read"`

		PaychNewPayment func(p0 context.Context, p1 address.Address, p2 address.Address, p3 []VoucherSpec) (*PaymentInfo, error) `perm:"sign"`

		PaychSettle func(p0 context.Context, p1 address.Address) (cid.Cid, error) `perm:"sign"`

		PaychStatus func(p0 context.Context, p1 address.Address) (*PaychStatus, error) `perm:"read"`

		PaychVoucherAdd func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 types.BigInt) (types.BigInt, error) `perm:"write"`

		PaychVoucherCheckSpendable func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (bool, error) `perm:"read"`

		PaychVoucherCheckValid func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher) error `perm:"read"`

		PaychVoucherCreate func(p0 context.Context, p1 address.Address, p2 types.BigInt, p3 uint64) (*VoucherCreateResult, error) `perm:"sign"`

		PaychVoucherList func(p0 context.Context, p1 address.Address) ([]*paych.SignedVoucher, error) `perm:"write"`

		PaychVoucherSubmit func(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (cid.Cid, error) `perm:"sign"`

		StateAccountKey func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) `perm:"read"`

		StateAllMinerFaults func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) ([]*Fault, error) `perm:"read"`

		StateCall func(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*InvocResult, error) `perm:"read"`

		StateChangedActors func(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (map[string]types.Actor, error) `perm:"read"`

		StateCirculatingSupply func(p0 context.Context, p1 types.TipSetKey) (abi.TokenAmount, error) `perm:"read"`

		StateCompute func(p0 context.Context, p1 abi.ChainEpoch, p2 []*types.Message, p3 types.TipSetKey) (*ComputeStateOutput, error) `perm:"read"`

		StateDealProviderCollateralBounds func(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) `perm:"read"`

		StateDecodeParams func(p0 context.Context, p1 address.Address, p2 abi.MethodNum, p3 []byte, p4 types.TipSetKey) (interface{}, error) `perm:"read"`

		StateGetActor func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) `perm:"read"`

		StateListActors func(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) `perm:"read"`

		StateListMessages func(p0 context.Context, p1 *MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) `perm:"read"`

		StateListMiners func(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) `perm:"read"`

		StateLookupID func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) `perm:"read"`

		StateMarketBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) `perm:"read"`

		StateMarketDeals func(p0 context.Context, p1 types.TipSetKey) (map[string]MarketDeal, error) `perm:"read"`

		StateMarketParticipants func(p0 context.Context, p1 types.TipSetKey) (map[string]MarketBalance, error) `perm:"read"`

		StateMarketStorageDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) `perm:"read"`

		StateMinerActiveSectors func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) `perm:"read"`

		StateMinerAvailableBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		StateMinerDeadlines func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]Deadline, error) `perm:"read"`

		StateMinerFaults func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) `perm:"read"`

		StateMinerInfo func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) `perm:"read"`

		StateMinerInitialPledgeCollateral func(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		StateMinerPartitions func(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) `perm:"read"`

		StateMinerPower func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) `perm:"read"`

		StateMinerPreCommitDepositForPower func(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) `perm:"read"`

		StateMinerProvingDeadline func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) `perm:"read"`

		StateMinerRecoveries func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) `perm:"read"`

		StateMinerSectorAllocated func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (bool, error) `perm:"read"`

		StateMinerSectorCount func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerSectors, error) `perm:"read"`

		StateMinerSectors func(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) `perm:"read"`

		StateNetworkName func(p0 context.Context) (dtypes.NetworkName, error) `perm:"read"`

		StateNetworkVersion func(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) `perm:"read"`

		StateReadState func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*ActorState, error) `perm:"read"`

		StateReplay func(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid) (*InvocResult, error) `perm:"read"`

		StateSearchMsg func(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) `perm:"read"`

		StateSectorExpiration func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorExpiration, error) `perm:"read"`

		StateSectorGetInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) `perm:"read"`

		StateSectorPartition func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) `perm:"read"`

		StateSectorPreCommitInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) `perm:"read"`

		StateVMCirculatingSupplyInternal func(p0 context.Context, p1 types.TipSetKey) (CirculatingSupply, error) `perm:"read"`

		StateVerifiedClientStatus func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) `perm:"read"`

		StateVerifiedRegistryRootKey func(p0 context.Context, p1 types.TipSetKey) (address.Address, error) `perm:"read"`

		StateVerifierStatus func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) `perm:"read"`

		StateWaitMsg func(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) `perm:"read"`

		SyncCheckBad func(p0 context.Context, p1 cid.Cid) (string, error) `perm:"read"`

		SyncCheckpoint func(p0 context.Context, p1 types.TipSetKey) error `perm:"admin"`

		SyncIncomingBlocks func(p0 context.Context) (<-chan *types.BlockHeader, error) `perm:"read"`

		SyncMarkBad func(p0 context.Context, p1 cid.Cid) error `perm:"admin"`

		SyncState func(p0 context.Context) (*SyncState, error) `perm:"read"`

		SyncSubmitBlock func(p0 context.Context, p1 *types.BlockMsg) error `perm:"write"`

		SyncUnmarkAllBad func(p0 context.Context) error `perm:"admin"`

		SyncUnmarkBad func(p0 context.Context, p1 cid.Cid) error `perm:"admin"`

		SyncValidateTipset func(p0 context.Context, p1 types.TipSetKey) (bool, error) `perm:"read"`

		WalletBalance func(p0 context.Context, p1 address.Address) (types.BigInt, error) `perm:"read"`

		WalletDefaultAddress func(p0 context.Context) (address.Address, error) `perm:"write"`

		WalletDelete func(p0 context.Context, p1 address.Address) error `perm:"admin"`

		WalletExport func(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) `perm:"admin"`

		WalletHas func(p0 context.Context, p1 address.Address) (bool, error) `perm:"write"`

		WalletImport func(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) `perm:"admin"`

		WalletList func(p0 context.Context) ([]address.Address, error) `perm:"write"`

		WalletNew func(p0 context.Context, p1 types.KeyType) (address.Address, error) `perm:"write"`

		WalletSetDefault func(p0 context.Context, p1 address.Address) error `perm:"write"`

		WalletSign func(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) `perm:"sign"`

		WalletSignMessage func(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) `perm:"sign"`

		WalletValidateAddress func(p0 context.Context, p1 string) (address.Address, error) `perm:"read"`

		WalletVerify func(p0 context.Context, p1 address.Address, p2 []byte, p3 *crypto.Signature) (bool, error) `perm:"read"`
	}
}

type FullNodeStub struct {
	CommonStub
}

type GatewayStruct struct {
	Internal struct {
		ChainGetBlockMessages func(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) ``

		ChainGetMessage func(p0 context.Context, p1 cid.Cid) (*types.Message, error) ``

		ChainGetTipSet func(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) ``

		ChainGetTipSetByHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) ``

		ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) ``

		ChainHead func(p0 context.Context) (*types.TipSet, error) ``

		ChainNotify func(p0 context.Context) (<-chan []*HeadChange, error) ``

		ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) ``

		GasEstimateMessageGas func(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) ``

		MpoolPush func(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) ``

		MsigGetAvailableBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) ``

		MsigGetPending func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) ``

		MsigGetVested func(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) ``

		StateAccountKey func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``

		StateDealProviderCollateralBounds func(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) ``

		StateGetActor func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) ``

		StateListMiners func(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) ``

		StateLookupID func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``

		StateMarketBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) ``

		StateMarketStorageDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) ``

		StateMinerInfo func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) ``

		StateMinerPower func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) ``

		StateMinerProvingDeadline func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) ``

		StateNetworkVersion func(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) ``

		StateSearchMsg func(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) ``

		StateSectorGetInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) ``

		StateVerifiedClientStatus func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) ``

		StateWaitMsg func(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) ``

		Version func(p0 context.Context) (APIVersion, error) ``

		WalletBalance func(p0 context.Context, p1 address.Address) (types.BigInt, error) ``
	}
}

type GatewayStub struct {
}

type SignableStruct struct {
	Internal struct {
		Sign func(p0 context.Context, p1 SignFunc) error ``
	}
}

type SignableStub struct {
}

type StorageMinerStruct struct {
	CommonStruct

	Internal struct {
		ActorAddress func(p0 context.Context) (address.Address, error) `perm:"read"`

		ActorAddressConfig func(p0 context.Context) (AddressConfig, error) `perm:"read"`

		ActorSectorSize func(p0 context.Context, p1 address.Address) (abi.SectorSize, error) `perm:"read"`

		CheckProvable func(p0 context.Context, p1 abi.RegisteredPoStProof, p2 []storage.SectorRef, p3 bool) (map[abi.SectorNumber]string, error) `perm:"admin"`

		ComputeProof func(p0 context.Context, p1 []builtin.SectorInfo, p2 abi.PoStRandomness) ([]builtin.PoStProof, error) `perm:"read"`

		CreateBackup func(p0 context.Context, p1 string) error `perm:"admin"`

		DealsConsiderOfflineRetrievalDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsConsiderOfflineStorageDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsConsiderOnlineRetrievalDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsConsiderOnlineStorageDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsConsiderUnverifiedStorageDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsConsiderVerifiedStorageDeals func(p0 context.Context) (bool, error) `perm:"admin"`

		DealsImportData func(p0 context.Context, p1 cid.Cid, p2 string) error `perm:"admin"`

		DealsList func(p0 context.Context) ([]MarketDeal, error) `perm:"admin"`

		DealsPieceCidBlocklist func(p0 context.Context) ([]cid.Cid, error) `perm:"admin"`

		DealsSetConsiderOfflineRetrievalDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetConsiderOfflineStorageDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetConsiderOnlineRetrievalDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetConsiderOnlineStorageDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetConsiderUnverifiedStorageDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetConsiderVerifiedStorageDeals func(p0 context.Context, p1 bool) error `perm:"admin"`

		DealsSetPieceCidBlocklist func(p0 context.Context, p1 []cid.Cid) error `perm:"admin"`

		MarketCancelDataTransfer func(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error `perm:"write"`

		MarketDataTransferUpdates func(p0 context.Context) (<-chan DataTransferChannel, error) `perm:"write"`

		MarketGetAsk func(p0 context.Context) (*storagemarket.SignedStorageAsk, error) `perm:"read"`

		MarketGetDealUpdates func(p0 context.Context) (<-chan storagemarket.MinerDeal, error) `perm:"read"`

		MarketGetRetrievalAsk func(p0 context.Context) (*retrievalmarket.Ask, error) `perm:"read"`

		MarketImportDealData func(p0 context.Context, p1 cid.Cid, p2 string) error `perm:"write"`

		MarketListDataTransfers func(p0 context.Context) ([]DataTransferChannel, error) `perm:"write"`

		MarketListDeals func(p0 context.Context) ([]MarketDeal, error) `perm:"read"`

		MarketListIncompleteDeals func(p0 context.Context) ([]storagemarket.MinerDeal, error) `perm:"read"`

		MarketListRetrievalDeals func(p0 context.Context) ([]retrievalmarket.ProviderDealState, error) `perm:"read"`

		MarketPendingDeals func(p0 context.Context) (PendingDealInfo, error) `perm:"write"`

		MarketPublishPendingDeals func(p0 context.Context) error `perm:"admin"`

		MarketRestartDataTransfer func(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error `perm:"write"`

		MarketSetAsk func(p0 context.Context, p1 types.BigInt, p2 types.BigInt, p3 abi.ChainEpoch, p4 abi.PaddedPieceSize, p5 abi.PaddedPieceSize) error `perm:"admin"`

		MarketSetRetrievalAsk func(p0 context.Context, p1 *retrievalmarket.Ask) error `perm:"admin"`

		MiningBase func(p0 context.Context) (*types.TipSet, error) `perm:"read"`

		PiecesGetCIDInfo func(p0 context.Context, p1 cid.Cid) (*piecestore.CIDInfo, error) `perm:"read"`

		PiecesGetPieceInfo func(p0 context.Context, p1 cid.Cid) (*piecestore.PieceInfo, error) `perm:"read"`

		PiecesListCidInfos func(p0 context.Context) ([]cid.Cid, error) `perm:"read"`

		PiecesListPieces func(p0 context.Context) ([]cid.Cid, error) `perm:"read"`

		PledgeSector func(p0 context.Context) (abi.SectorID, error) `perm:"write"`

		ReturnAddPiece func(p0 context.Context, p1 storiface.CallID, p2 abi.PieceInfo, p3 *storiface.CallError) error `perm:"admin"`

		ReturnFetch func(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error `perm:"admin"`

		ReturnFinalizeSector func(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error `perm:"admin"`

		ReturnMoveStorage func(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error `perm:"admin"`

		ReturnReadPiece func(p0 context.Context, p1 storiface.CallID, p2 bool, p3 *storiface.CallError) error `perm:"admin"`

		ReturnReleaseUnsealed func(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error `perm:"admin"`

		ReturnSealCommit1 func(p0 context.Context, p1 storiface.CallID, p2 storage.Commit1Out, p3 *storiface.CallError) error `perm:"admin"`

		ReturnSealCommit2 func(p0 context.Context, p1 storiface.CallID, p2 storage.Proof, p3 *storiface.CallError) error `perm:"admin"`

		ReturnSealPreCommit1 func(p0 context.Context, p1 storiface.CallID, p2 storage.PreCommit1Out, p3 *storiface.CallError) error `perm:"admin"`

		ReturnSealPreCommit2 func(p0 context.Context, p1 storiface.CallID, p2 storage.SectorCids, p3 *storiface.CallError) error `perm:"admin"`

		ReturnUnsealPiece func(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error `perm:"admin"`

		SealingAbort func(p0 context.Context, p1 storiface.CallID) error `perm:"admin"`

		SealingSchedDiag func(p0 context.Context, p1 bool) (interface{}, error) `perm:"admin"`

		SectorCommitFlush func(p0 context.Context) ([]sealiface.CommitBatchRes, error) `perm:"admin"`

		SectorCommitPending func(p0 context.Context) ([]abi.SectorID, error) `perm:"admin"`

		SectorGetExpectedSealDuration func(p0 context.Context) (time.Duration, error) `perm:"read"`

		SectorGetSealDelay func(p0 context.Context) (time.Duration, error) `perm:"read"`

		SectorMarkForUpgrade func(p0 context.Context, p1 abi.SectorNumber) error `perm:"admin"`

		SectorPreCommitFlush func(p0 context.Context) ([]sealiface.PreCommitBatchRes, error) `perm:"admin"`

		SectorPreCommitPending func(p0 context.Context) ([]abi.SectorID, error) `perm:"admin"`

		SectorRemove func(p0 context.Context, p1 abi.SectorNumber) error `perm:"admin"`

		SectorSetExpectedSealDuration func(p0 context.Context, p1 time.Duration) error `perm:"write"`

		SectorSetSealDelay func(p0 context.Context, p1 time.Duration) error `perm:"write"`

		SectorStartSealing func(p0 context.Context, p1 abi.SectorNumber) error `perm:"write"`

		SectorTerminate func(p0 context.Context, p1 abi.SectorNumber) error `perm:"admin"`

		SectorTerminateFlush func(p0 context.Context) (*cid.Cid, error) `perm:"admin"`

		SectorTerminatePending func(p0 context.Context) ([]abi.SectorID, error) `perm:"admin"`

		SectorsList func(p0 context.Context) ([]abi.SectorNumber, error) `perm:"read"`

		SectorsListInStates func(p0 context.Context, p1 []SectorState) ([]abi.SectorNumber, error) `perm:"read"`

		SectorsRefs func(p0 context.Context) (map[string][]SealedRef, error) `perm:"read"`

		SectorsStatus func(p0 context.Context, p1 abi.SectorNumber, p2 bool) (SectorInfo, error) `perm:"read"`

		SectorsSummary func(p0 context.Context) (map[SectorState]int, error) `perm:"read"`

		SectorsUpdate func(p0 context.Context, p1 abi.SectorNumber, p2 SectorState) error `perm:"admin"`

		StorageAddLocal func(p0 context.Context, p1 string) error `perm:"admin"`

		StorageAttach func(p0 context.Context, p1 stores.StorageInfo, p2 fsutil.FsStat) error `perm:"admin"`

		StorageBestAlloc func(p0 context.Context, p1 storiface.SectorFileType, p2 abi.SectorSize, p3 storiface.PathType) ([]stores.StorageInfo, error) `perm:"admin"`

		StorageDeclareSector func(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType, p4 bool) error `perm:"admin"`

		StorageDropSector func(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType) error `perm:"admin"`

		StorageFindSector func(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]stores.SectorStorageInfo, error) `perm:"admin"`

		StorageInfo func(p0 context.Context, p1 stores.ID) (stores.StorageInfo, error) `perm:"admin"`

		StorageList func(p0 context.Context) (map[stores.ID][]stores.Decl, error) `perm:"admin"`

		StorageLocal func(p0 context.Context) (map[stores.ID]string, error) `perm:"admin"`

		StorageLock func(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) error `perm:"admin"`

		StorageReportHealth func(p0 context.Context, p1 stores.ID, p2 stores.HealthReport) error `perm:"admin"`

		StorageStat func(p0 context.Context, p1 stores.ID) (fsutil.FsStat, error) `perm:"admin"`

		StorageTryLock func(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) (bool, error) `perm:"admin"`

		WorkerConnect func(p0 context.Context, p1 string) error `perm:"admin"`

		WorkerJobs func(p0 context.Context) (map[uuid.UUID][]storiface.WorkerJob, error) `perm:"admin"`

		WorkerStats func(p0 context.Context) (map[uuid.UUID]storiface.WorkerStats, error) `perm:"admin"`
	}
}

type StorageMinerStub struct {
	CommonStub
}

type WalletStruct struct {
	Internal struct {
		WalletDelete func(p0 context.Context, p1 address.Address) error `perm:"admin"`

		WalletExport func(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) `perm:"admin"`

		WalletHas func(p0 context.Context, p1 address.Address) (bool, error) `perm:"admin"`

		WalletImport func(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) `perm:"admin"`

		WalletList func(p0 context.Context) ([]address.Address, error) `perm:"admin"`

		WalletNew func(p0 context.Context, p1 types.KeyType) (address.Address, error) `perm:"admin"`

		WalletSign func(p0 context.Context, p1 address.Address, p2 []byte, p3 MsgMeta) (*crypto.Signature, error) `perm:"admin"`
	}
}

type WalletStub struct {
}

type WorkerStruct struct {
	Internal struct {
		AddPiece func(p0 context.Context, p1 storage.SectorRef, p2 []abi.UnpaddedPieceSize, p3 abi.UnpaddedPieceSize, p4 storage.Data) (storiface.CallID, error) `perm:"admin"`

		Enabled func(p0 context.Context) (bool, error) `perm:"admin"`

		Fetch func(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType, p3 storiface.PathType, p4 storiface.AcquireMode) (storiface.CallID, error) `perm:"admin"`

		FinalizeSector func(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) `perm:"admin"`

		Info func(p0 context.Context) (storiface.WorkerInfo, error) `perm:"admin"`

		MoveStorage func(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType) (storiface.CallID, error) `perm:"admin"`

		Paths func(p0 context.Context) ([]stores.StoragePath, error) `perm:"admin"`

		ProcessSession func(p0 context.Context) (uuid.UUID, error) `perm:"admin"`

		ReleaseUnsealed func(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) `perm:"admin"`

		Remove func(p0 context.Context, p1 abi.SectorID) error `perm:"admin"`

		SealCommit1 func(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 abi.InteractiveSealRandomness, p4 []abi.PieceInfo, p5 storage.SectorCids) (storiface.CallID, error) `perm:"admin"`

		SealCommit2 func(p0 context.Context, p1 storage.SectorRef, p2 storage.Commit1Out) (storiface.CallID, error) `perm:"admin"`

		SealPreCommit1 func(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 []abi.PieceInfo) (storiface.CallID, error) `perm:"admin"`

		SealPreCommit2 func(p0 context.Context, p1 storage.SectorRef, p2 storage.PreCommit1Out) (storiface.CallID, error) `perm:"admin"`

		Session func(p0 context.Context) (uuid.UUID, error) `perm:"admin"`

		SetEnabled func(p0 context.Context, p1 bool) error `perm:"admin"`

		StorageAddLocal func(p0 context.Context, p1 string) error `perm:"admin"`

		TaskDisable func(p0 context.Context, p1 sealtasks.TaskType) error `perm:"admin"`

		TaskEnable func(p0 context.Context, p1 sealtasks.TaskType) error `perm:"admin"`

		TaskTypes func(p0 context.Context) (map[sealtasks.TaskType]struct{}, error) `perm:"admin"`

		UnsealPiece func(p0 context.Context, p1 storage.SectorRef, p2 storiface.UnpaddedByteIndex, p3 abi.UnpaddedPieceSize, p4 abi.SealRandomness, p5 cid.Cid) (storiface.CallID, error) `perm:"admin"`

		Version func(p0 context.Context) (Version, error) `perm:"admin"`

		WaitQuiet func(p0 context.Context) error `perm:"admin"`
	}
}

type WorkerStub struct {
}

func (s *ChainIOStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *ChainIOStub) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *ChainIOStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *ChainIOStub) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return *new([]byte), xerrors.New("method not supported")
}

func (s *CommonStruct) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	return s.Internal.AuthNew(p0, p1)
}

func (s *CommonStub) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	return *new([]byte), xerrors.New("method not supported")
}

func (s *CommonStruct) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	return s.Internal.AuthVerify(p0, p1)
}

func (s *CommonStub) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	return *new([]auth.Permission), xerrors.New("method not supported")
}

func (s *CommonStruct) Closing(p0 context.Context) (<-chan struct{}, error) {
	return s.Internal.Closing(p0)
}

func (s *CommonStub) Closing(p0 context.Context) (<-chan struct{}, error) {
	return nil, xerrors.New("method not supported")
}

func (s *CommonStruct) Discover(p0 context.Context) (apitypes.OpenRPCDocument, error) {
	return s.Internal.Discover(p0)
}

func (s *CommonStub) Discover(p0 context.Context) (apitypes.OpenRPCDocument, error) {
	return *new(apitypes.OpenRPCDocument), xerrors.New("method not supported")
}

func (s *CommonStruct) ID(p0 context.Context) (peer.ID, error) {
	return s.Internal.ID(p0)
}

func (s *CommonStub) ID(p0 context.Context) (peer.ID, error) {
	return *new(peer.ID), xerrors.New("method not supported")
}

func (s *CommonStruct) LogList(p0 context.Context) ([]string, error) {
	return s.Internal.LogList(p0)
}

func (s *CommonStub) LogList(p0 context.Context) ([]string, error) {
	return *new([]string), xerrors.New("method not supported")
}

func (s *CommonStruct) LogSetLevel(p0 context.Context, p1 string, p2 string) error {
	return s.Internal.LogSetLevel(p0, p1, p2)
}

func (s *CommonStub) LogSetLevel(p0 context.Context, p1 string, p2 string) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) NetAddrsListen(p0 context.Context) (peer.AddrInfo, error) {
	return s.Internal.NetAddrsListen(p0)
}

func (s *CommonStub) NetAddrsListen(p0 context.Context) (peer.AddrInfo, error) {
	return *new(peer.AddrInfo), xerrors.New("method not supported")
}

func (s *CommonStruct) NetAgentVersion(p0 context.Context, p1 peer.ID) (string, error) {
	return s.Internal.NetAgentVersion(p0, p1)
}

func (s *CommonStub) NetAgentVersion(p0 context.Context, p1 peer.ID) (string, error) {
	return "", xerrors.New("method not supported")
}

func (s *CommonStruct) NetAutoNatStatus(p0 context.Context) (NatInfo, error) {
	return s.Internal.NetAutoNatStatus(p0)
}

func (s *CommonStub) NetAutoNatStatus(p0 context.Context) (NatInfo, error) {
	return *new(NatInfo), xerrors.New("method not supported")
}

func (s *CommonStruct) NetBandwidthStats(p0 context.Context) (metrics.Stats, error) {
	return s.Internal.NetBandwidthStats(p0)
}

func (s *CommonStub) NetBandwidthStats(p0 context.Context) (metrics.Stats, error) {
	return *new(metrics.Stats), xerrors.New("method not supported")
}

func (s *CommonStruct) NetBandwidthStatsByPeer(p0 context.Context) (map[string]metrics.Stats, error) {
	return s.Internal.NetBandwidthStatsByPeer(p0)
}

func (s *CommonStub) NetBandwidthStatsByPeer(p0 context.Context) (map[string]metrics.Stats, error) {
	return *new(map[string]metrics.Stats), xerrors.New("method not supported")
}

func (s *CommonStruct) NetBandwidthStatsByProtocol(p0 context.Context) (map[protocol.ID]metrics.Stats, error) {
	return s.Internal.NetBandwidthStatsByProtocol(p0)
}

func (s *CommonStub) NetBandwidthStatsByProtocol(p0 context.Context) (map[protocol.ID]metrics.Stats, error) {
	return *new(map[protocol.ID]metrics.Stats), xerrors.New("method not supported")
}

func (s *CommonStruct) NetBlockAdd(p0 context.Context, p1 NetBlockList) error {
	return s.Internal.NetBlockAdd(p0, p1)
}

func (s *CommonStub) NetBlockAdd(p0 context.Context, p1 NetBlockList) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) NetBlockList(p0 context.Context) (NetBlockList, error) {
	return s.Internal.NetBlockList(p0)
}

func (s *CommonStub) NetBlockList(p0 context.Context) (NetBlockList, error) {
	return *new(NetBlockList), xerrors.New("method not supported")
}

func (s *CommonStruct) NetBlockRemove(p0 context.Context, p1 NetBlockList) error {
	return s.Internal.NetBlockRemove(p0, p1)
}

func (s *CommonStub) NetBlockRemove(p0 context.Context, p1 NetBlockList) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) NetConnect(p0 context.Context, p1 peer.AddrInfo) error {
	return s.Internal.NetConnect(p0, p1)
}

func (s *CommonStub) NetConnect(p0 context.Context, p1 peer.AddrInfo) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) NetConnectedness(p0 context.Context, p1 peer.ID) (network.Connectedness, error) {
	return s.Internal.NetConnectedness(p0, p1)
}

func (s *CommonStub) NetConnectedness(p0 context.Context, p1 peer.ID) (network.Connectedness, error) {
	return *new(network.Connectedness), xerrors.New("method not supported")
}

func (s *CommonStruct) NetDisconnect(p0 context.Context, p1 peer.ID) error {
	return s.Internal.NetDisconnect(p0, p1)
}

func (s *CommonStub) NetDisconnect(p0 context.Context, p1 peer.ID) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) NetFindPeer(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) {
	return s.Internal.NetFindPeer(p0, p1)
}

func (s *CommonStub) NetFindPeer(p0 context.Context, p1 peer.ID) (peer.AddrInfo, error) {
	return *new(peer.AddrInfo), xerrors.New("method not supported")
}

func (s *CommonStruct) NetPeerInfo(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) {
	return s.Internal.NetPeerInfo(p0, p1)
}

func (s *CommonStub) NetPeerInfo(p0 context.Context, p1 peer.ID) (*ExtendedPeerInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *CommonStruct) NetPeers(p0 context.Context) ([]peer.AddrInfo, error) {
	return s.Internal.NetPeers(p0)
}

func (s *CommonStub) NetPeers(p0 context.Context) ([]peer.AddrInfo, error) {
	return *new([]peer.AddrInfo), xerrors.New("method not supported")
}

func (s *CommonStruct) NetPubsubScores(p0 context.Context) ([]PubsubScore, error) {
	return s.Internal.NetPubsubScores(p0)
}

func (s *CommonStub) NetPubsubScores(p0 context.Context) ([]PubsubScore, error) {
	return *new([]PubsubScore), xerrors.New("method not supported")
}

func (s *CommonStruct) Session(p0 context.Context) (uuid.UUID, error) {
	return s.Internal.Session(p0)
}

func (s *CommonStub) Session(p0 context.Context) (uuid.UUID, error) {
	return *new(uuid.UUID), xerrors.New("method not supported")
}

func (s *CommonStruct) Shutdown(p0 context.Context) error {
	return s.Internal.Shutdown(p0)
}

func (s *CommonStub) Shutdown(p0 context.Context) error {
	return xerrors.New("method not supported")
}

func (s *CommonStruct) Version(p0 context.Context) (APIVersion, error) {
	return s.Internal.Version(p0)
}

func (s *CommonStub) Version(p0 context.Context) (APIVersion, error) {
	return *new(APIVersion), xerrors.New("method not supported")
}

func (s *FullNodeStruct) BeaconGetEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	return s.Internal.BeaconGetEntry(p0, p1)
}

func (s *FullNodeStub) BeaconGetEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainDeleteObj(p0 context.Context, p1 cid.Cid) error {
	return s.Internal.ChainDeleteObj(p0, p1)
}

func (s *FullNodeStub) ChainDeleteObj(p0 context.Context, p1 cid.Cid) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainExport(p0 context.Context, p1 abi.ChainEpoch, p2 bool, p3 types.TipSetKey) (<-chan []byte, error) {
	return s.Internal.ChainExport(p0, p1, p2, p3)
}

func (s *FullNodeStub) ChainExport(p0 context.Context, p1 abi.ChainEpoch, p2 bool, p3 types.TipSetKey) (<-chan []byte, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetBlock(p0 context.Context, p1 cid.Cid) (*types.BlockHeader, error) {
	return s.Internal.ChainGetBlock(p0, p1)
}

func (s *FullNodeStub) ChainGetBlock(p0 context.Context, p1 cid.Cid) (*types.BlockHeader, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetBlockMessages(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) {
	return s.Internal.ChainGetBlockMessages(p0, p1)
}

func (s *FullNodeStub) ChainGetBlockMessages(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetGenesis(p0 context.Context) (*types.TipSet, error) {
	return s.Internal.ChainGetGenesis(p0)
}

func (s *FullNodeStub) ChainGetGenesis(p0 context.Context) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return s.Internal.ChainGetMessage(p0, p1)
}

func (s *FullNodeStub) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetNode(p0 context.Context, p1 string) (*IpldObject, error) {
	return s.Internal.ChainGetNode(p0, p1)
}

func (s *FullNodeStub) ChainGetNode(p0 context.Context, p1 string) (*IpldObject, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetParentMessages(p0 context.Context, p1 cid.Cid) ([]Message, error) {
	return s.Internal.ChainGetParentMessages(p0, p1)
}

func (s *FullNodeStub) ChainGetParentMessages(p0 context.Context, p1 cid.Cid) ([]Message, error) {
	return *new([]Message), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetParentReceipts(p0 context.Context, p1 cid.Cid) ([]*types.MessageReceipt, error) {
	return s.Internal.ChainGetParentReceipts(p0, p1)
}

func (s *FullNodeStub) ChainGetParentReceipts(p0 context.Context, p1 cid.Cid) ([]*types.MessageReceipt, error) {
	return *new([]*types.MessageReceipt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetPath(p0 context.Context, p1 types.TipSetKey, p2 types.TipSetKey) ([]*HeadChange, error) {
	return s.Internal.ChainGetPath(p0, p1, p2)
}

func (s *FullNodeStub) ChainGetPath(p0 context.Context, p1 types.TipSetKey, p2 types.TipSetKey) ([]*HeadChange, error) {
	return *new([]*HeadChange), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetRandomnessFromBeacon(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return s.Internal.ChainGetRandomnessFromBeacon(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) ChainGetRandomnessFromBeacon(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return *new(abi.Randomness), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetRandomnessFromTickets(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return s.Internal.ChainGetRandomnessFromTickets(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) ChainGetRandomnessFromTickets(p0 context.Context, p1 types.TipSetKey, p2 crypto.DomainSeparationTag, p3 abi.ChainEpoch, p4 []byte) (abi.Randomness, error) {
	return *new(abi.Randomness), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return s.Internal.ChainGetTipSet(p0, p1)
}

func (s *FullNodeStub) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return s.Internal.ChainGetTipSetByHeight(p0, p1, p2)
}

func (s *FullNodeStub) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *FullNodeStub) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return s.Internal.ChainHead(p0)
}

func (s *FullNodeStub) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	return s.Internal.ChainNotify(p0)
}

func (s *FullNodeStub) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *FullNodeStub) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return *new([]byte), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainSetHead(p0 context.Context, p1 types.TipSetKey) error {
	return s.Internal.ChainSetHead(p0, p1)
}

func (s *FullNodeStub) ChainSetHead(p0 context.Context, p1 types.TipSetKey) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainStatObj(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (ObjStat, error) {
	return s.Internal.ChainStatObj(p0, p1, p2)
}

func (s *FullNodeStub) ChainStatObj(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (ObjStat, error) {
	return *new(ObjStat), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.ChainTipSetWeight(p0, p1)
}

func (s *FullNodeStub) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientCalcCommP(p0 context.Context, p1 string) (*CommPRet, error) {
	return s.Internal.ClientCalcCommP(p0, p1)
}

func (s *FullNodeStub) ClientCalcCommP(p0 context.Context, p1 string) (*CommPRet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientCancelDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return s.Internal.ClientCancelDataTransfer(p0, p1, p2, p3)
}

func (s *FullNodeStub) ClientCancelDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientCancelRetrievalDeal(p0 context.Context, p1 retrievalmarket.DealID) error {
	return s.Internal.ClientCancelRetrievalDeal(p0, p1)
}

func (s *FullNodeStub) ClientCancelRetrievalDeal(p0 context.Context, p1 retrievalmarket.DealID) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientDataTransferUpdates(p0 context.Context) (<-chan DataTransferChannel, error) {
	return s.Internal.ClientDataTransferUpdates(p0)
}

func (s *FullNodeStub) ClientDataTransferUpdates(p0 context.Context) (<-chan DataTransferChannel, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientDealPieceCID(p0 context.Context, p1 cid.Cid) (DataCIDSize, error) {
	return s.Internal.ClientDealPieceCID(p0, p1)
}

func (s *FullNodeStub) ClientDealPieceCID(p0 context.Context, p1 cid.Cid) (DataCIDSize, error) {
	return *new(DataCIDSize), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientDealSize(p0 context.Context, p1 cid.Cid) (DataSize, error) {
	return s.Internal.ClientDealSize(p0, p1)
}

func (s *FullNodeStub) ClientDealSize(p0 context.Context, p1 cid.Cid) (DataSize, error) {
	return *new(DataSize), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientFindData(p0 context.Context, p1 cid.Cid, p2 *cid.Cid) ([]QueryOffer, error) {
	return s.Internal.ClientFindData(p0, p1, p2)
}

func (s *FullNodeStub) ClientFindData(p0 context.Context, p1 cid.Cid, p2 *cid.Cid) ([]QueryOffer, error) {
	return *new([]QueryOffer), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientGenCar(p0 context.Context, p1 FileRef, p2 string) error {
	return s.Internal.ClientGenCar(p0, p1, p2)
}

func (s *FullNodeStub) ClientGenCar(p0 context.Context, p1 FileRef, p2 string) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientGetDealInfo(p0 context.Context, p1 cid.Cid) (*DealInfo, error) {
	return s.Internal.ClientGetDealInfo(p0, p1)
}

func (s *FullNodeStub) ClientGetDealInfo(p0 context.Context, p1 cid.Cid) (*DealInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientGetDealStatus(p0 context.Context, p1 uint64) (string, error) {
	return s.Internal.ClientGetDealStatus(p0, p1)
}

func (s *FullNodeStub) ClientGetDealStatus(p0 context.Context, p1 uint64) (string, error) {
	return "", xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientGetDealUpdates(p0 context.Context) (<-chan DealInfo, error) {
	return s.Internal.ClientGetDealUpdates(p0)
}

func (s *FullNodeStub) ClientGetDealUpdates(p0 context.Context) (<-chan DealInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientGetRetrievalUpdates(p0 context.Context) (<-chan RetrievalInfo, error) {
	return s.Internal.ClientGetRetrievalUpdates(p0)
}

func (s *FullNodeStub) ClientGetRetrievalUpdates(p0 context.Context) (<-chan RetrievalInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientHasLocal(p0 context.Context, p1 cid.Cid) (bool, error) {
	return s.Internal.ClientHasLocal(p0, p1)
}

func (s *FullNodeStub) ClientHasLocal(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientImport(p0 context.Context, p1 FileRef) (*ImportRes, error) {
	return s.Internal.ClientImport(p0, p1)
}

func (s *FullNodeStub) ClientImport(p0 context.Context, p1 FileRef) (*ImportRes, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientListDataTransfers(p0 context.Context) ([]DataTransferChannel, error) {
	return s.Internal.ClientListDataTransfers(p0)
}

func (s *FullNodeStub) ClientListDataTransfers(p0 context.Context) ([]DataTransferChannel, error) {
	return *new([]DataTransferChannel), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientListDeals(p0 context.Context) ([]DealInfo, error) {
	return s.Internal.ClientListDeals(p0)
}

func (s *FullNodeStub) ClientListDeals(p0 context.Context) ([]DealInfo, error) {
	return *new([]DealInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientListImports(p0 context.Context) ([]Import, error) {
	return s.Internal.ClientListImports(p0)
}

func (s *FullNodeStub) ClientListImports(p0 context.Context) ([]Import, error) {
	return *new([]Import), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientListRetrievals(p0 context.Context) ([]RetrievalInfo, error) {
	return s.Internal.ClientListRetrievals(p0)
}

func (s *FullNodeStub) ClientListRetrievals(p0 context.Context) ([]RetrievalInfo, error) {
	return *new([]RetrievalInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientMinerQueryOffer(p0 context.Context, p1 address.Address, p2 cid.Cid, p3 *cid.Cid) (QueryOffer, error) {
	return s.Internal.ClientMinerQueryOffer(p0, p1, p2, p3)
}

func (s *FullNodeStub) ClientMinerQueryOffer(p0 context.Context, p1 address.Address, p2 cid.Cid, p3 *cid.Cid) (QueryOffer, error) {
	return *new(QueryOffer), xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientQueryAsk(p0 context.Context, p1 peer.ID, p2 address.Address) (*storagemarket.StorageAsk, error) {
	return s.Internal.ClientQueryAsk(p0, p1, p2)
}

func (s *FullNodeStub) ClientQueryAsk(p0 context.Context, p1 peer.ID, p2 address.Address) (*storagemarket.StorageAsk, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientRemoveImport(p0 context.Context, p1 multistore.StoreID) error {
	return s.Internal.ClientRemoveImport(p0, p1)
}

func (s *FullNodeStub) ClientRemoveImport(p0 context.Context, p1 multistore.StoreID) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientRestartDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return s.Internal.ClientRestartDataTransfer(p0, p1, p2, p3)
}

func (s *FullNodeStub) ClientRestartDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientRetrieve(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) error {
	return s.Internal.ClientRetrieve(p0, p1, p2)
}

func (s *FullNodeStub) ClientRetrieve(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientRetrieveTryRestartInsufficientFunds(p0 context.Context, p1 address.Address) error {
	return s.Internal.ClientRetrieveTryRestartInsufficientFunds(p0, p1)
}

func (s *FullNodeStub) ClientRetrieveTryRestartInsufficientFunds(p0 context.Context, p1 address.Address) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientRetrieveWithEvents(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) (<-chan marketevents.RetrievalEvent, error) {
	return s.Internal.ClientRetrieveWithEvents(p0, p1, p2)
}

func (s *FullNodeStub) ClientRetrieveWithEvents(p0 context.Context, p1 RetrievalOrder, p2 *FileRef) (<-chan marketevents.RetrievalEvent, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientStartDeal(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) {
	return s.Internal.ClientStartDeal(p0, p1)
}

func (s *FullNodeStub) ClientStartDeal(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) ClientStatelessDeal(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) {
	return s.Internal.ClientStatelessDeal(p0, p1)
}

func (s *FullNodeStub) ClientStatelessDeal(p0 context.Context, p1 *StartDealParams) (*cid.Cid, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) CreateBackup(p0 context.Context, p1 string) error {
	return s.Internal.CreateBackup(p0, p1)
}

func (s *FullNodeStub) CreateBackup(p0 context.Context, p1 string) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.GasEstimateFeeCap(p0, p1, p2, p3)
}

func (s *FullNodeStub) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) GasEstimateGasLimit(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (int64, error) {
	return s.Internal.GasEstimateGasLimit(p0, p1, p2)
}

func (s *FullNodeStub) GasEstimateGasLimit(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (int64, error) {
	return 0, xerrors.New("method not supported")
}

func (s *FullNodeStruct) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.GasEstimateGasPremium(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return s.Internal.GasEstimateMessageGas(p0, p1, p2, p3)
}

func (s *FullNodeStub) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MarketAddBalance(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return s.Internal.MarketAddBalance(p0, p1, p2, p3)
}

func (s *FullNodeStub) MarketAddBalance(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MarketGetReserved(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return s.Internal.MarketGetReserved(p0, p1)
}

func (s *FullNodeStub) MarketGetReserved(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MarketReleaseFunds(p0 context.Context, p1 address.Address, p2 types.BigInt) error {
	return s.Internal.MarketReleaseFunds(p0, p1, p2)
}

func (s *FullNodeStub) MarketReleaseFunds(p0 context.Context, p1 address.Address, p2 types.BigInt) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) MarketReserveFunds(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return s.Internal.MarketReserveFunds(p0, p1, p2, p3)
}

func (s *FullNodeStub) MarketReserveFunds(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MarketWithdraw(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return s.Internal.MarketWithdraw(p0, p1, p2, p3)
}

func (s *FullNodeStub) MarketWithdraw(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MinerCreateBlock(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) {
	return s.Internal.MinerCreateBlock(p0, p1)
}

func (s *FullNodeStub) MinerCreateBlock(p0 context.Context, p1 *BlockTemplate) (*types.BlockMsg, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) {
	return s.Internal.MinerGetBaseInfo(p0, p1, p2, p3)
}

func (s *FullNodeStub) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*MiningBaseInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolBatchPush(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) {
	return s.Internal.MpoolBatchPush(p0, p1)
}

func (s *FullNodeStub) MpoolBatchPush(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolBatchPushMessage(p0 context.Context, p1 []*types.Message, p2 *MessageSendSpec) ([]*types.SignedMessage, error) {
	return s.Internal.MpoolBatchPushMessage(p0, p1, p2)
}

func (s *FullNodeStub) MpoolBatchPushMessage(p0 context.Context, p1 []*types.Message, p2 *MessageSendSpec) ([]*types.SignedMessage, error) {
	return *new([]*types.SignedMessage), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolBatchPushUntrusted(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) {
	return s.Internal.MpoolBatchPushUntrusted(p0, p1)
}

func (s *FullNodeStub) MpoolBatchPushUntrusted(p0 context.Context, p1 []*types.SignedMessage) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolCheckMessages(p0 context.Context, p1 []*MessagePrototype) ([][]MessageCheckStatus, error) {
	return s.Internal.MpoolCheckMessages(p0, p1)
}

func (s *FullNodeStub) MpoolCheckMessages(p0 context.Context, p1 []*MessagePrototype) ([][]MessageCheckStatus, error) {
	return *new([][]MessageCheckStatus), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolCheckPendingMessages(p0 context.Context, p1 address.Address) ([][]MessageCheckStatus, error) {
	return s.Internal.MpoolCheckPendingMessages(p0, p1)
}

func (s *FullNodeStub) MpoolCheckPendingMessages(p0 context.Context, p1 address.Address) ([][]MessageCheckStatus, error) {
	return *new([][]MessageCheckStatus), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolCheckReplaceMessages(p0 context.Context, p1 []*types.Message) ([][]MessageCheckStatus, error) {
	return s.Internal.MpoolCheckReplaceMessages(p0, p1)
}

func (s *FullNodeStub) MpoolCheckReplaceMessages(p0 context.Context, p1 []*types.Message) ([][]MessageCheckStatus, error) {
	return *new([][]MessageCheckStatus), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolClear(p0 context.Context, p1 bool) error {
	return s.Internal.MpoolClear(p0, p1)
}

func (s *FullNodeStub) MpoolClear(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolGetConfig(p0 context.Context) (*types.MpoolConfig, error) {
	return s.Internal.MpoolGetConfig(p0)
}

func (s *FullNodeStub) MpoolGetConfig(p0 context.Context) (*types.MpoolConfig, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	return s.Internal.MpoolGetNonce(p0, p1)
}

func (s *FullNodeStub) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	return 0, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolPending(p0 context.Context, p1 types.TipSetKey) ([]*types.SignedMessage, error) {
	return s.Internal.MpoolPending(p0, p1)
}

func (s *FullNodeStub) MpoolPending(p0 context.Context, p1 types.TipSetKey) ([]*types.SignedMessage, error) {
	return *new([]*types.SignedMessage), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return s.Internal.MpoolPush(p0, p1)
}

func (s *FullNodeStub) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) {
	return s.Internal.MpoolPushMessage(p0, p1, p2)
}

func (s *FullNodeStub) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec) (*types.SignedMessage, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolPushUntrusted(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return s.Internal.MpoolPushUntrusted(p0, p1)
}

func (s *FullNodeStub) MpoolPushUntrusted(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	return s.Internal.MpoolSelect(p0, p1, p2)
}

func (s *FullNodeStub) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	return *new([]*types.SignedMessage), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolSetConfig(p0 context.Context, p1 *types.MpoolConfig) error {
	return s.Internal.MpoolSetConfig(p0, p1)
}

func (s *FullNodeStub) MpoolSetConfig(p0 context.Context, p1 *types.MpoolConfig) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) MpoolSub(p0 context.Context) (<-chan MpoolUpdate, error) {
	return s.Internal.MpoolSub(p0)
}

func (s *FullNodeStub) MpoolSub(p0 context.Context) (<-chan MpoolUpdate, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigAddApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 bool) (*MessagePrototype, error) {
	return s.Internal.MsigAddApprove(p0, p1, p2, p3, p4, p5, p6)
}

func (s *FullNodeStub) MsigAddApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 bool) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigAddCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 bool) (*MessagePrototype, error) {
	return s.Internal.MsigAddCancel(p0, p1, p2, p3, p4, p5)
}

func (s *FullNodeStub) MsigAddCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 bool) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigAddPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) {
	return s.Internal.MsigAddPropose(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) MsigAddPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigApprove(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address) (*MessagePrototype, error) {
	return s.Internal.MsigApprove(p0, p1, p2, p3)
}

func (s *FullNodeStub) MsigApprove(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigApproveTxnHash(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 address.Address, p5 types.BigInt, p6 address.Address, p7 uint64, p8 []byte) (*MessagePrototype, error) {
	return s.Internal.MsigApproveTxnHash(p0, p1, p2, p3, p4, p5, p6, p7, p8)
}

func (s *FullNodeStub) MsigApproveTxnHash(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 address.Address, p5 types.BigInt, p6 address.Address, p7 uint64, p8 []byte) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigCancel(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 types.BigInt, p5 address.Address, p6 uint64, p7 []byte) (*MessagePrototype, error) {
	return s.Internal.MsigCancel(p0, p1, p2, p3, p4, p5, p6, p7)
}

func (s *FullNodeStub) MsigCancel(p0 context.Context, p1 address.Address, p2 uint64, p3 address.Address, p4 types.BigInt, p5 address.Address, p6 uint64, p7 []byte) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigCreate(p0 context.Context, p1 uint64, p2 []address.Address, p3 abi.ChainEpoch, p4 types.BigInt, p5 address.Address, p6 types.BigInt) (*MessagePrototype, error) {
	return s.Internal.MsigCreate(p0, p1, p2, p3, p4, p5, p6)
}

func (s *FullNodeStub) MsigCreate(p0 context.Context, p1 uint64, p2 []address.Address, p3 abi.ChainEpoch, p4 types.BigInt, p5 address.Address, p6 types.BigInt) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigGetAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.MsigGetAvailableBalance(p0, p1, p2)
}

func (s *FullNodeStub) MsigGetAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigGetPending(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) {
	return s.Internal.MsigGetPending(p0, p1, p2)
}

func (s *FullNodeStub) MsigGetPending(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) {
	return *new([]*MsigTransaction), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigGetVested(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.MsigGetVested(p0, p1, p2, p3)
}

func (s *FullNodeStub) MsigGetVested(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigGetVestingSchedule(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MsigVesting, error) {
	return s.Internal.MsigGetVestingSchedule(p0, p1, p2)
}

func (s *FullNodeStub) MsigGetVestingSchedule(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MsigVesting, error) {
	return *new(MsigVesting), xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt, p4 address.Address, p5 uint64, p6 []byte) (*MessagePrototype, error) {
	return s.Internal.MsigPropose(p0, p1, p2, p3, p4, p5, p6)
}

func (s *FullNodeStub) MsigPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt, p4 address.Address, p5 uint64, p6 []byte) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigRemoveSigner(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) {
	return s.Internal.MsigRemoveSigner(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) MsigRemoveSigner(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 bool) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigSwapApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 address.Address) (*MessagePrototype, error) {
	return s.Internal.MsigSwapApprove(p0, p1, p2, p3, p4, p5, p6)
}

func (s *FullNodeStub) MsigSwapApprove(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address, p6 address.Address) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigSwapCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address) (*MessagePrototype, error) {
	return s.Internal.MsigSwapCancel(p0, p1, p2, p3, p4, p5)
}

func (s *FullNodeStub) MsigSwapCancel(p0 context.Context, p1 address.Address, p2 address.Address, p3 uint64, p4 address.Address, p5 address.Address) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) MsigSwapPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 address.Address) (*MessagePrototype, error) {
	return s.Internal.MsigSwapPropose(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) MsigSwapPropose(p0 context.Context, p1 address.Address, p2 address.Address, p3 address.Address, p4 address.Address) (*MessagePrototype, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) NodeStatus(p0 context.Context, p1 bool) (NodeStatus, error) {
	return s.Internal.NodeStatus(p0, p1)
}

func (s *FullNodeStub) NodeStatus(p0 context.Context, p1 bool) (NodeStatus, error) {
	return *new(NodeStatus), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychAllocateLane(p0 context.Context, p1 address.Address) (uint64, error) {
	return s.Internal.PaychAllocateLane(p0, p1)
}

func (s *FullNodeStub) PaychAllocateLane(p0 context.Context, p1 address.Address) (uint64, error) {
	return 0, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychAvailableFunds(p0 context.Context, p1 address.Address) (*ChannelAvailableFunds, error) {
	return s.Internal.PaychAvailableFunds(p0, p1)
}

func (s *FullNodeStub) PaychAvailableFunds(p0 context.Context, p1 address.Address) (*ChannelAvailableFunds, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychAvailableFundsByFromTo(p0 context.Context, p1 address.Address, p2 address.Address) (*ChannelAvailableFunds, error) {
	return s.Internal.PaychAvailableFundsByFromTo(p0, p1, p2)
}

func (s *FullNodeStub) PaychAvailableFundsByFromTo(p0 context.Context, p1 address.Address, p2 address.Address) (*ChannelAvailableFunds, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychCollect(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return s.Internal.PaychCollect(p0, p1)
}

func (s *FullNodeStub) PaychCollect(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychGet(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (*ChannelInfo, error) {
	return s.Internal.PaychGet(p0, p1, p2, p3)
}

func (s *FullNodeStub) PaychGet(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (*ChannelInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychGetWaitReady(p0 context.Context, p1 cid.Cid) (address.Address, error) {
	return s.Internal.PaychGetWaitReady(p0, p1)
}

func (s *FullNodeStub) PaychGetWaitReady(p0 context.Context, p1 cid.Cid) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychList(p0 context.Context) ([]address.Address, error) {
	return s.Internal.PaychList(p0)
}

func (s *FullNodeStub) PaychList(p0 context.Context) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychNewPayment(p0 context.Context, p1 address.Address, p2 address.Address, p3 []VoucherSpec) (*PaymentInfo, error) {
	return s.Internal.PaychNewPayment(p0, p1, p2, p3)
}

func (s *FullNodeStub) PaychNewPayment(p0 context.Context, p1 address.Address, p2 address.Address, p3 []VoucherSpec) (*PaymentInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychSettle(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return s.Internal.PaychSettle(p0, p1)
}

func (s *FullNodeStub) PaychSettle(p0 context.Context, p1 address.Address) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychStatus(p0 context.Context, p1 address.Address) (*PaychStatus, error) {
	return s.Internal.PaychStatus(p0, p1)
}

func (s *FullNodeStub) PaychStatus(p0 context.Context, p1 address.Address) (*PaychStatus, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherAdd(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 types.BigInt) (types.BigInt, error) {
	return s.Internal.PaychVoucherAdd(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) PaychVoucherAdd(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 types.BigInt) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherCheckSpendable(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (bool, error) {
	return s.Internal.PaychVoucherCheckSpendable(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) PaychVoucherCheckSpendable(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherCheckValid(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher) error {
	return s.Internal.PaychVoucherCheckValid(p0, p1, p2)
}

func (s *FullNodeStub) PaychVoucherCheckValid(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherCreate(p0 context.Context, p1 address.Address, p2 types.BigInt, p3 uint64) (*VoucherCreateResult, error) {
	return s.Internal.PaychVoucherCreate(p0, p1, p2, p3)
}

func (s *FullNodeStub) PaychVoucherCreate(p0 context.Context, p1 address.Address, p2 types.BigInt, p3 uint64) (*VoucherCreateResult, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherList(p0 context.Context, p1 address.Address) ([]*paych.SignedVoucher, error) {
	return s.Internal.PaychVoucherList(p0, p1)
}

func (s *FullNodeStub) PaychVoucherList(p0 context.Context, p1 address.Address) ([]*paych.SignedVoucher, error) {
	return *new([]*paych.SignedVoucher), xerrors.New("method not supported")
}

func (s *FullNodeStruct) PaychVoucherSubmit(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (cid.Cid, error) {
	return s.Internal.PaychVoucherSubmit(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) PaychVoucherSubmit(p0 context.Context, p1 address.Address, p2 *paych.SignedVoucher, p3 []byte, p4 []byte) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return s.Internal.StateAccountKey(p0, p1, p2)
}

func (s *FullNodeStub) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateAllMinerFaults(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) ([]*Fault, error) {
	return s.Internal.StateAllMinerFaults(p0, p1, p2)
}

func (s *FullNodeStub) StateAllMinerFaults(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) ([]*Fault, error) {
	return *new([]*Fault), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateCall(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*InvocResult, error) {
	return s.Internal.StateCall(p0, p1, p2)
}

func (s *FullNodeStub) StateCall(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*InvocResult, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateChangedActors(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (map[string]types.Actor, error) {
	return s.Internal.StateChangedActors(p0, p1, p2)
}

func (s *FullNodeStub) StateChangedActors(p0 context.Context, p1 cid.Cid, p2 cid.Cid) (map[string]types.Actor, error) {
	return *new(map[string]types.Actor), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateCirculatingSupply(p0 context.Context, p1 types.TipSetKey) (abi.TokenAmount, error) {
	return s.Internal.StateCirculatingSupply(p0, p1)
}

func (s *FullNodeStub) StateCirculatingSupply(p0 context.Context, p1 types.TipSetKey) (abi.TokenAmount, error) {
	return *new(abi.TokenAmount), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateCompute(p0 context.Context, p1 abi.ChainEpoch, p2 []*types.Message, p3 types.TipSetKey) (*ComputeStateOutput, error) {
	return s.Internal.StateCompute(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateCompute(p0 context.Context, p1 abi.ChainEpoch, p2 []*types.Message, p3 types.TipSetKey) (*ComputeStateOutput, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) {
	return s.Internal.StateDealProviderCollateralBounds(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) {
	return *new(DealCollateralBounds), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateDecodeParams(p0 context.Context, p1 address.Address, p2 abi.MethodNum, p3 []byte, p4 types.TipSetKey) (interface{}, error) {
	return s.Internal.StateDecodeParams(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) StateDecodeParams(p0 context.Context, p1 address.Address, p2 abi.MethodNum, p3 []byte, p4 types.TipSetKey) (interface{}, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return s.Internal.StateGetActor(p0, p1, p2)
}

func (s *FullNodeStub) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateListActors(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return s.Internal.StateListActors(p0, p1)
}

func (s *FullNodeStub) StateListActors(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateListMessages(p0 context.Context, p1 *MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) {
	return s.Internal.StateListMessages(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateListMessages(p0 context.Context, p1 *MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return s.Internal.StateListMiners(p0, p1)
}

func (s *FullNodeStub) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return s.Internal.StateLookupID(p0, p1, p2)
}

func (s *FullNodeStub) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) {
	return s.Internal.StateMarketBalance(p0, p1, p2)
}

func (s *FullNodeStub) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) {
	return *new(MarketBalance), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMarketDeals(p0 context.Context, p1 types.TipSetKey) (map[string]MarketDeal, error) {
	return s.Internal.StateMarketDeals(p0, p1)
}

func (s *FullNodeStub) StateMarketDeals(p0 context.Context, p1 types.TipSetKey) (map[string]MarketDeal, error) {
	return *new(map[string]MarketDeal), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMarketParticipants(p0 context.Context, p1 types.TipSetKey) (map[string]MarketBalance, error) {
	return s.Internal.StateMarketParticipants(p0, p1)
}

func (s *FullNodeStub) StateMarketParticipants(p0 context.Context, p1 types.TipSetKey) (map[string]MarketBalance, error) {
	return *new(map[string]MarketBalance), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) {
	return s.Internal.StateMarketStorageDeal(p0, p1, p2)
}

func (s *FullNodeStub) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return s.Internal.StateMinerActiveSectors(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return *new([]*miner.SectorOnChainInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.StateMinerAvailableBalance(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerDeadlines(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]Deadline, error) {
	return s.Internal.StateMinerDeadlines(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerDeadlines(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]Deadline, error) {
	return *new([]Deadline), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerFaults(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return s.Internal.StateMinerFaults(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerFaults(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return *new(bitfield.BitField), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) {
	return s.Internal.StateMinerInfo(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) {
	return *new(miner.MinerInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerInitialPledgeCollateral(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.StateMinerInitialPledgeCollateral(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateMinerInitialPledgeCollateral(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) {
	return s.Internal.StateMinerPartitions(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]Partition, error) {
	return *new([]Partition), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) {
	return s.Internal.StateMinerPower(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.StateMinerPreCommitDepositForPower(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return s.Internal.StateMinerProvingDeadline(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerRecoveries(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return s.Internal.StateMinerRecoveries(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerRecoveries(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return *new(bitfield.BitField), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerSectorAllocated(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (bool, error) {
	return s.Internal.StateMinerSectorAllocated(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateMinerSectorAllocated(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerSectorCount(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerSectors, error) {
	return s.Internal.StateMinerSectorCount(p0, p1, p2)
}

func (s *FullNodeStub) StateMinerSectorCount(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MinerSectors, error) {
	return *new(MinerSectors), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return s.Internal.StateMinerSectors(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return *new([]*miner.SectorOnChainInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateNetworkName(p0 context.Context) (dtypes.NetworkName, error) {
	return s.Internal.StateNetworkName(p0)
}

func (s *FullNodeStub) StateNetworkName(p0 context.Context) (dtypes.NetworkName, error) {
	return *new(dtypes.NetworkName), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) {
	return s.Internal.StateNetworkVersion(p0, p1)
}

func (s *FullNodeStub) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) {
	return *new(apitypes.NetworkVersion), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateReadState(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*ActorState, error) {
	return s.Internal.StateReadState(p0, p1, p2)
}

func (s *FullNodeStub) StateReadState(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*ActorState, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateReplay(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid) (*InvocResult, error) {
	return s.Internal.StateReplay(p0, p1, p2)
}

func (s *FullNodeStub) StateReplay(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid) (*InvocResult, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return s.Internal.StateSearchMsg(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateSectorExpiration(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorExpiration, error) {
	return s.Internal.StateSectorExpiration(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateSectorExpiration(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorExpiration, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return s.Internal.StateSectorGetInfo(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) {
	return s.Internal.StateSectorPartition(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) {
	return s.Internal.StateSectorPreCommitInfo(p0, p1, p2, p3)
}

func (s *FullNodeStub) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) {
	return *new(miner.SectorPreCommitOnChainInfo), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateVMCirculatingSupplyInternal(p0 context.Context, p1 types.TipSetKey) (CirculatingSupply, error) {
	return s.Internal.StateVMCirculatingSupplyInternal(p0, p1)
}

func (s *FullNodeStub) StateVMCirculatingSupplyInternal(p0 context.Context, p1 types.TipSetKey) (CirculatingSupply, error) {
	return *new(CirculatingSupply), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return s.Internal.StateVerifiedClientStatus(p0, p1, p2)
}

func (s *FullNodeStub) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateVerifiedRegistryRootKey(p0 context.Context, p1 types.TipSetKey) (address.Address, error) {
	return s.Internal.StateVerifiedRegistryRootKey(p0, p1)
}

func (s *FullNodeStub) StateVerifiedRegistryRootKey(p0 context.Context, p1 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateVerifierStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return s.Internal.StateVerifierStatus(p0, p1, p2)
}

func (s *FullNodeStub) StateVerifierStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return s.Internal.StateWaitMsg(p0, p1, p2, p3, p4)
}

func (s *FullNodeStub) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncCheckBad(p0 context.Context, p1 cid.Cid) (string, error) {
	return s.Internal.SyncCheckBad(p0, p1)
}

func (s *FullNodeStub) SyncCheckBad(p0 context.Context, p1 cid.Cid) (string, error) {
	return "", xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncCheckpoint(p0 context.Context, p1 types.TipSetKey) error {
	return s.Internal.SyncCheckpoint(p0, p1)
}

func (s *FullNodeStub) SyncCheckpoint(p0 context.Context, p1 types.TipSetKey) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncIncomingBlocks(p0 context.Context) (<-chan *types.BlockHeader, error) {
	return s.Internal.SyncIncomingBlocks(p0)
}

func (s *FullNodeStub) SyncIncomingBlocks(p0 context.Context) (<-chan *types.BlockHeader, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncMarkBad(p0 context.Context, p1 cid.Cid) error {
	return s.Internal.SyncMarkBad(p0, p1)
}

func (s *FullNodeStub) SyncMarkBad(p0 context.Context, p1 cid.Cid) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncState(p0 context.Context) (*SyncState, error) {
	return s.Internal.SyncState(p0)
}

func (s *FullNodeStub) SyncState(p0 context.Context) (*SyncState, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) error {
	return s.Internal.SyncSubmitBlock(p0, p1)
}

func (s *FullNodeStub) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncUnmarkAllBad(p0 context.Context) error {
	return s.Internal.SyncUnmarkAllBad(p0)
}

func (s *FullNodeStub) SyncUnmarkAllBad(p0 context.Context) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncUnmarkBad(p0 context.Context, p1 cid.Cid) error {
	return s.Internal.SyncUnmarkBad(p0, p1)
}

func (s *FullNodeStub) SyncUnmarkBad(p0 context.Context, p1 cid.Cid) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) SyncValidateTipset(p0 context.Context, p1 types.TipSetKey) (bool, error) {
	return s.Internal.SyncValidateTipset(p0, p1)
}

func (s *FullNodeStub) SyncValidateTipset(p0 context.Context, p1 types.TipSetKey) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletBalance(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return s.Internal.WalletBalance(p0, p1)
}

func (s *FullNodeStub) WalletBalance(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletDefaultAddress(p0 context.Context) (address.Address, error) {
	return s.Internal.WalletDefaultAddress(p0)
}

func (s *FullNodeStub) WalletDefaultAddress(p0 context.Context) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletDelete(p0 context.Context, p1 address.Address) error {
	return s.Internal.WalletDelete(p0, p1)
}

func (s *FullNodeStub) WalletDelete(p0 context.Context, p1 address.Address) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletExport(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) {
	return s.Internal.WalletExport(p0, p1)
}

func (s *FullNodeStub) WalletExport(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return s.Internal.WalletHas(p0, p1)
}

func (s *FullNodeStub) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletImport(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) {
	return s.Internal.WalletImport(p0, p1)
}

func (s *FullNodeStub) WalletImport(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletList(p0 context.Context) ([]address.Address, error) {
	return s.Internal.WalletList(p0)
}

func (s *FullNodeStub) WalletList(p0 context.Context) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletNew(p0 context.Context, p1 types.KeyType) (address.Address, error) {
	return s.Internal.WalletNew(p0, p1)
}

func (s *FullNodeStub) WalletNew(p0 context.Context, p1 types.KeyType) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletSetDefault(p0 context.Context, p1 address.Address) error {
	return s.Internal.WalletSetDefault(p0, p1)
}

func (s *FullNodeStub) WalletSetDefault(p0 context.Context, p1 address.Address) error {
	return xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	return s.Internal.WalletSign(p0, p1, p2)
}

func (s *FullNodeStub) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	return s.Internal.WalletSignMessage(p0, p1, p2)
}

func (s *FullNodeStub) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	return nil, xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletValidateAddress(p0 context.Context, p1 string) (address.Address, error) {
	return s.Internal.WalletValidateAddress(p0, p1)
}

func (s *FullNodeStub) WalletValidateAddress(p0 context.Context, p1 string) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *FullNodeStruct) WalletVerify(p0 context.Context, p1 address.Address, p2 []byte, p3 *crypto.Signature) (bool, error) {
	return s.Internal.WalletVerify(p0, p1, p2, p3)
}

func (s *FullNodeStub) WalletVerify(p0 context.Context, p1 address.Address, p2 []byte, p3 *crypto.Signature) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainGetBlockMessages(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) {
	return s.Internal.ChainGetBlockMessages(p0, p1)
}

func (s *GatewayStub) ChainGetBlockMessages(p0 context.Context, p1 cid.Cid) (*BlockMessages, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return s.Internal.ChainGetMessage(p0, p1)
}

func (s *GatewayStub) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return s.Internal.ChainGetTipSet(p0, p1)
}

func (s *GatewayStub) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return s.Internal.ChainGetTipSetByHeight(p0, p1, p2)
}

func (s *GatewayStub) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *GatewayStub) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return s.Internal.ChainHead(p0)
}

func (s *GatewayStub) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	return s.Internal.ChainNotify(p0)
}

func (s *GatewayStub) ChainNotify(p0 context.Context) (<-chan []*HeadChange, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *GatewayStub) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return *new([]byte), xerrors.New("method not supported")
}

func (s *GatewayStruct) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return s.Internal.GasEstimateMessageGas(p0, p1, p2, p3)
}

func (s *GatewayStub) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return s.Internal.MpoolPush(p0, p1)
}

func (s *GatewayStub) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return *new(cid.Cid), xerrors.New("method not supported")
}

func (s *GatewayStruct) MsigGetAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.MsigGetAvailableBalance(p0, p1, p2)
}

func (s *GatewayStub) MsigGetAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *GatewayStruct) MsigGetPending(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) {
	return s.Internal.MsigGetPending(p0, p1, p2)
}

func (s *GatewayStub) MsigGetPending(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*MsigTransaction, error) {
	return *new([]*MsigTransaction), xerrors.New("method not supported")
}

func (s *GatewayStruct) MsigGetVested(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) {
	return s.Internal.MsigGetVested(p0, p1, p2, p3)
}

func (s *GatewayStub) MsigGetVested(p0 context.Context, p1 address.Address, p2 types.TipSetKey, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return s.Internal.StateAccountKey(p0, p1, p2)
}

func (s *GatewayStub) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) {
	return s.Internal.StateDealProviderCollateralBounds(p0, p1, p2, p3)
}

func (s *GatewayStub) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (DealCollateralBounds, error) {
	return *new(DealCollateralBounds), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return s.Internal.StateGetActor(p0, p1, p2)
}

func (s *GatewayStub) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return s.Internal.StateListMiners(p0, p1)
}

func (s *GatewayStub) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return s.Internal.StateLookupID(p0, p1, p2)
}

func (s *GatewayStub) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) {
	return s.Internal.StateMarketBalance(p0, p1, p2)
}

func (s *GatewayStub) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (MarketBalance, error) {
	return *new(MarketBalance), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) {
	return s.Internal.StateMarketStorageDeal(p0, p1, p2)
}

func (s *GatewayStub) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*MarketDeal, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) {
	return s.Internal.StateMinerInfo(p0, p1, p2)
}

func (s *GatewayStub) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (miner.MinerInfo, error) {
	return *new(miner.MinerInfo), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) {
	return s.Internal.StateMinerPower(p0, p1, p2)
}

func (s *GatewayStub) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*MinerPower, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return s.Internal.StateMinerProvingDeadline(p0, p1, p2)
}

func (s *GatewayStub) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) {
	return s.Internal.StateNetworkVersion(p0, p1)
}

func (s *GatewayStub) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (apitypes.NetworkVersion, error) {
	return *new(apitypes.NetworkVersion), xerrors.New("method not supported")
}

func (s *GatewayStruct) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return s.Internal.StateSearchMsg(p0, p1, p2, p3, p4)
}

func (s *GatewayStub) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return s.Internal.StateSectorGetInfo(p0, p1, p2, p3)
}

func (s *GatewayStub) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return s.Internal.StateVerifiedClientStatus(p0, p1, p2)
}

func (s *GatewayStub) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return s.Internal.StateWaitMsg(p0, p1, p2, p3, p4)
}

func (s *GatewayStub) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*MsgLookup, error) {
	return nil, xerrors.New("method not supported")
}

func (s *GatewayStruct) Version(p0 context.Context) (APIVersion, error) {
	return s.Internal.Version(p0)
}

func (s *GatewayStub) Version(p0 context.Context) (APIVersion, error) {
	return *new(APIVersion), xerrors.New("method not supported")
}

func (s *GatewayStruct) WalletBalance(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return s.Internal.WalletBalance(p0, p1)
}

func (s *GatewayStub) WalletBalance(p0 context.Context, p1 address.Address) (types.BigInt, error) {
	return *new(types.BigInt), xerrors.New("method not supported")
}

func (s *SignableStruct) Sign(p0 context.Context, p1 SignFunc) error {
	return s.Internal.Sign(p0, p1)
}

func (s *SignableStub) Sign(p0 context.Context, p1 SignFunc) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ActorAddress(p0 context.Context) (address.Address, error) {
	return s.Internal.ActorAddress(p0)
}

func (s *StorageMinerStub) ActorAddress(p0 context.Context) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ActorAddressConfig(p0 context.Context) (AddressConfig, error) {
	return s.Internal.ActorAddressConfig(p0)
}

func (s *StorageMinerStub) ActorAddressConfig(p0 context.Context) (AddressConfig, error) {
	return *new(AddressConfig), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ActorSectorSize(p0 context.Context, p1 address.Address) (abi.SectorSize, error) {
	return s.Internal.ActorSectorSize(p0, p1)
}

func (s *StorageMinerStub) ActorSectorSize(p0 context.Context, p1 address.Address) (abi.SectorSize, error) {
	return *new(abi.SectorSize), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) CheckProvable(p0 context.Context, p1 abi.RegisteredPoStProof, p2 []storage.SectorRef, p3 bool) (map[abi.SectorNumber]string, error) {
	return s.Internal.CheckProvable(p0, p1, p2, p3)
}

func (s *StorageMinerStub) CheckProvable(p0 context.Context, p1 abi.RegisteredPoStProof, p2 []storage.SectorRef, p3 bool) (map[abi.SectorNumber]string, error) {
	return *new(map[abi.SectorNumber]string), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ComputeProof(p0 context.Context, p1 []builtin.SectorInfo, p2 abi.PoStRandomness) ([]builtin.PoStProof, error) {
	return s.Internal.ComputeProof(p0, p1, p2)
}

func (s *StorageMinerStub) ComputeProof(p0 context.Context, p1 []builtin.SectorInfo, p2 abi.PoStRandomness) ([]builtin.PoStProof, error) {
	return *new([]builtin.PoStProof), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) CreateBackup(p0 context.Context, p1 string) error {
	return s.Internal.CreateBackup(p0, p1)
}

func (s *StorageMinerStub) CreateBackup(p0 context.Context, p1 string) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderOfflineRetrievalDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderOfflineRetrievalDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderOfflineRetrievalDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderOfflineStorageDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderOfflineStorageDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderOfflineStorageDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderOnlineRetrievalDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderOnlineRetrievalDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderOnlineRetrievalDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderOnlineStorageDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderOnlineStorageDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderOnlineStorageDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderUnverifiedStorageDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderUnverifiedStorageDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderUnverifiedStorageDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsConsiderVerifiedStorageDeals(p0 context.Context) (bool, error) {
	return s.Internal.DealsConsiderVerifiedStorageDeals(p0)
}

func (s *StorageMinerStub) DealsConsiderVerifiedStorageDeals(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsImportData(p0 context.Context, p1 cid.Cid, p2 string) error {
	return s.Internal.DealsImportData(p0, p1, p2)
}

func (s *StorageMinerStub) DealsImportData(p0 context.Context, p1 cid.Cid, p2 string) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsList(p0 context.Context) ([]MarketDeal, error) {
	return s.Internal.DealsList(p0)
}

func (s *StorageMinerStub) DealsList(p0 context.Context) ([]MarketDeal, error) {
	return *new([]MarketDeal), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsPieceCidBlocklist(p0 context.Context) ([]cid.Cid, error) {
	return s.Internal.DealsPieceCidBlocklist(p0)
}

func (s *StorageMinerStub) DealsPieceCidBlocklist(p0 context.Context) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderOfflineRetrievalDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderOfflineRetrievalDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderOfflineRetrievalDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderOfflineStorageDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderOfflineStorageDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderOfflineStorageDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderOnlineRetrievalDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderOnlineRetrievalDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderOnlineRetrievalDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderOnlineStorageDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderOnlineStorageDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderOnlineStorageDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderUnverifiedStorageDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderUnverifiedStorageDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderUnverifiedStorageDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetConsiderVerifiedStorageDeals(p0 context.Context, p1 bool) error {
	return s.Internal.DealsSetConsiderVerifiedStorageDeals(p0, p1)
}

func (s *StorageMinerStub) DealsSetConsiderVerifiedStorageDeals(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) DealsSetPieceCidBlocklist(p0 context.Context, p1 []cid.Cid) error {
	return s.Internal.DealsSetPieceCidBlocklist(p0, p1)
}

func (s *StorageMinerStub) DealsSetPieceCidBlocklist(p0 context.Context, p1 []cid.Cid) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketCancelDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return s.Internal.MarketCancelDataTransfer(p0, p1, p2, p3)
}

func (s *StorageMinerStub) MarketCancelDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketDataTransferUpdates(p0 context.Context) (<-chan DataTransferChannel, error) {
	return s.Internal.MarketDataTransferUpdates(p0)
}

func (s *StorageMinerStub) MarketDataTransferUpdates(p0 context.Context) (<-chan DataTransferChannel, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketGetAsk(p0 context.Context) (*storagemarket.SignedStorageAsk, error) {
	return s.Internal.MarketGetAsk(p0)
}

func (s *StorageMinerStub) MarketGetAsk(p0 context.Context) (*storagemarket.SignedStorageAsk, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketGetDealUpdates(p0 context.Context) (<-chan storagemarket.MinerDeal, error) {
	return s.Internal.MarketGetDealUpdates(p0)
}

func (s *StorageMinerStub) MarketGetDealUpdates(p0 context.Context) (<-chan storagemarket.MinerDeal, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketGetRetrievalAsk(p0 context.Context) (*retrievalmarket.Ask, error) {
	return s.Internal.MarketGetRetrievalAsk(p0)
}

func (s *StorageMinerStub) MarketGetRetrievalAsk(p0 context.Context) (*retrievalmarket.Ask, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketImportDealData(p0 context.Context, p1 cid.Cid, p2 string) error {
	return s.Internal.MarketImportDealData(p0, p1, p2)
}

func (s *StorageMinerStub) MarketImportDealData(p0 context.Context, p1 cid.Cid, p2 string) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketListDataTransfers(p0 context.Context) ([]DataTransferChannel, error) {
	return s.Internal.MarketListDataTransfers(p0)
}

func (s *StorageMinerStub) MarketListDataTransfers(p0 context.Context) ([]DataTransferChannel, error) {
	return *new([]DataTransferChannel), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketListDeals(p0 context.Context) ([]MarketDeal, error) {
	return s.Internal.MarketListDeals(p0)
}

func (s *StorageMinerStub) MarketListDeals(p0 context.Context) ([]MarketDeal, error) {
	return *new([]MarketDeal), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketListIncompleteDeals(p0 context.Context) ([]storagemarket.MinerDeal, error) {
	return s.Internal.MarketListIncompleteDeals(p0)
}

func (s *StorageMinerStub) MarketListIncompleteDeals(p0 context.Context) ([]storagemarket.MinerDeal, error) {
	return *new([]storagemarket.MinerDeal), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketListRetrievalDeals(p0 context.Context) ([]retrievalmarket.ProviderDealState, error) {
	return s.Internal.MarketListRetrievalDeals(p0)
}

func (s *StorageMinerStub) MarketListRetrievalDeals(p0 context.Context) ([]retrievalmarket.ProviderDealState, error) {
	return *new([]retrievalmarket.ProviderDealState), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketPendingDeals(p0 context.Context) (PendingDealInfo, error) {
	return s.Internal.MarketPendingDeals(p0)
}

func (s *StorageMinerStub) MarketPendingDeals(p0 context.Context) (PendingDealInfo, error) {
	return *new(PendingDealInfo), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketPublishPendingDeals(p0 context.Context) error {
	return s.Internal.MarketPublishPendingDeals(p0)
}

func (s *StorageMinerStub) MarketPublishPendingDeals(p0 context.Context) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketRestartDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return s.Internal.MarketRestartDataTransfer(p0, p1, p2, p3)
}

func (s *StorageMinerStub) MarketRestartDataTransfer(p0 context.Context, p1 datatransfer.TransferID, p2 peer.ID, p3 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketSetAsk(p0 context.Context, p1 types.BigInt, p2 types.BigInt, p3 abi.ChainEpoch, p4 abi.PaddedPieceSize, p5 abi.PaddedPieceSize) error {
	return s.Internal.MarketSetAsk(p0, p1, p2, p3, p4, p5)
}

func (s *StorageMinerStub) MarketSetAsk(p0 context.Context, p1 types.BigInt, p2 types.BigInt, p3 abi.ChainEpoch, p4 abi.PaddedPieceSize, p5 abi.PaddedPieceSize) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MarketSetRetrievalAsk(p0 context.Context, p1 *retrievalmarket.Ask) error {
	return s.Internal.MarketSetRetrievalAsk(p0, p1)
}

func (s *StorageMinerStub) MarketSetRetrievalAsk(p0 context.Context, p1 *retrievalmarket.Ask) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) MiningBase(p0 context.Context) (*types.TipSet, error) {
	return s.Internal.MiningBase(p0)
}

func (s *StorageMinerStub) MiningBase(p0 context.Context) (*types.TipSet, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) PiecesGetCIDInfo(p0 context.Context, p1 cid.Cid) (*piecestore.CIDInfo, error) {
	return s.Internal.PiecesGetCIDInfo(p0, p1)
}

func (s *StorageMinerStub) PiecesGetCIDInfo(p0 context.Context, p1 cid.Cid) (*piecestore.CIDInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) PiecesGetPieceInfo(p0 context.Context, p1 cid.Cid) (*piecestore.PieceInfo, error) {
	return s.Internal.PiecesGetPieceInfo(p0, p1)
}

func (s *StorageMinerStub) PiecesGetPieceInfo(p0 context.Context, p1 cid.Cid) (*piecestore.PieceInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) PiecesListCidInfos(p0 context.Context) ([]cid.Cid, error) {
	return s.Internal.PiecesListCidInfos(p0)
}

func (s *StorageMinerStub) PiecesListCidInfos(p0 context.Context) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) PiecesListPieces(p0 context.Context) ([]cid.Cid, error) {
	return s.Internal.PiecesListPieces(p0)
}

func (s *StorageMinerStub) PiecesListPieces(p0 context.Context) ([]cid.Cid, error) {
	return *new([]cid.Cid), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) PledgeSector(p0 context.Context) (abi.SectorID, error) {
	return s.Internal.PledgeSector(p0)
}

func (s *StorageMinerStub) PledgeSector(p0 context.Context) (abi.SectorID, error) {
	return *new(abi.SectorID), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnAddPiece(p0 context.Context, p1 storiface.CallID, p2 abi.PieceInfo, p3 *storiface.CallError) error {
	return s.Internal.ReturnAddPiece(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnAddPiece(p0 context.Context, p1 storiface.CallID, p2 abi.PieceInfo, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnFetch(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return s.Internal.ReturnFetch(p0, p1, p2)
}

func (s *StorageMinerStub) ReturnFetch(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnFinalizeSector(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return s.Internal.ReturnFinalizeSector(p0, p1, p2)
}

func (s *StorageMinerStub) ReturnFinalizeSector(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnMoveStorage(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return s.Internal.ReturnMoveStorage(p0, p1, p2)
}

func (s *StorageMinerStub) ReturnMoveStorage(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnReadPiece(p0 context.Context, p1 storiface.CallID, p2 bool, p3 *storiface.CallError) error {
	return s.Internal.ReturnReadPiece(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnReadPiece(p0 context.Context, p1 storiface.CallID, p2 bool, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnReleaseUnsealed(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return s.Internal.ReturnReleaseUnsealed(p0, p1, p2)
}

func (s *StorageMinerStub) ReturnReleaseUnsealed(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnSealCommit1(p0 context.Context, p1 storiface.CallID, p2 storage.Commit1Out, p3 *storiface.CallError) error {
	return s.Internal.ReturnSealCommit1(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnSealCommit1(p0 context.Context, p1 storiface.CallID, p2 storage.Commit1Out, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnSealCommit2(p0 context.Context, p1 storiface.CallID, p2 storage.Proof, p3 *storiface.CallError) error {
	return s.Internal.ReturnSealCommit2(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnSealCommit2(p0 context.Context, p1 storiface.CallID, p2 storage.Proof, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnSealPreCommit1(p0 context.Context, p1 storiface.CallID, p2 storage.PreCommit1Out, p3 *storiface.CallError) error {
	return s.Internal.ReturnSealPreCommit1(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnSealPreCommit1(p0 context.Context, p1 storiface.CallID, p2 storage.PreCommit1Out, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnSealPreCommit2(p0 context.Context, p1 storiface.CallID, p2 storage.SectorCids, p3 *storiface.CallError) error {
	return s.Internal.ReturnSealPreCommit2(p0, p1, p2, p3)
}

func (s *StorageMinerStub) ReturnSealPreCommit2(p0 context.Context, p1 storiface.CallID, p2 storage.SectorCids, p3 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) ReturnUnsealPiece(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return s.Internal.ReturnUnsealPiece(p0, p1, p2)
}

func (s *StorageMinerStub) ReturnUnsealPiece(p0 context.Context, p1 storiface.CallID, p2 *storiface.CallError) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SealingAbort(p0 context.Context, p1 storiface.CallID) error {
	return s.Internal.SealingAbort(p0, p1)
}

func (s *StorageMinerStub) SealingAbort(p0 context.Context, p1 storiface.CallID) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SealingSchedDiag(p0 context.Context, p1 bool) (interface{}, error) {
	return s.Internal.SealingSchedDiag(p0, p1)
}

func (s *StorageMinerStub) SealingSchedDiag(p0 context.Context, p1 bool) (interface{}, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorCommitFlush(p0 context.Context) ([]sealiface.CommitBatchRes, error) {
	return s.Internal.SectorCommitFlush(p0)
}

func (s *StorageMinerStub) SectorCommitFlush(p0 context.Context) ([]sealiface.CommitBatchRes, error) {
	return *new([]sealiface.CommitBatchRes), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorCommitPending(p0 context.Context) ([]abi.SectorID, error) {
	return s.Internal.SectorCommitPending(p0)
}

func (s *StorageMinerStub) SectorCommitPending(p0 context.Context) ([]abi.SectorID, error) {
	return *new([]abi.SectorID), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorGetExpectedSealDuration(p0 context.Context) (time.Duration, error) {
	return s.Internal.SectorGetExpectedSealDuration(p0)
}

func (s *StorageMinerStub) SectorGetExpectedSealDuration(p0 context.Context) (time.Duration, error) {
	return *new(time.Duration), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorGetSealDelay(p0 context.Context) (time.Duration, error) {
	return s.Internal.SectorGetSealDelay(p0)
}

func (s *StorageMinerStub) SectorGetSealDelay(p0 context.Context) (time.Duration, error) {
	return *new(time.Duration), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorMarkForUpgrade(p0 context.Context, p1 abi.SectorNumber) error {
	return s.Internal.SectorMarkForUpgrade(p0, p1)
}

func (s *StorageMinerStub) SectorMarkForUpgrade(p0 context.Context, p1 abi.SectorNumber) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorPreCommitFlush(p0 context.Context) ([]sealiface.PreCommitBatchRes, error) {
	return s.Internal.SectorPreCommitFlush(p0)
}

func (s *StorageMinerStub) SectorPreCommitFlush(p0 context.Context) ([]sealiface.PreCommitBatchRes, error) {
	return *new([]sealiface.PreCommitBatchRes), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorPreCommitPending(p0 context.Context) ([]abi.SectorID, error) {
	return s.Internal.SectorPreCommitPending(p0)
}

func (s *StorageMinerStub) SectorPreCommitPending(p0 context.Context) ([]abi.SectorID, error) {
	return *new([]abi.SectorID), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorRemove(p0 context.Context, p1 abi.SectorNumber) error {
	return s.Internal.SectorRemove(p0, p1)
}

func (s *StorageMinerStub) SectorRemove(p0 context.Context, p1 abi.SectorNumber) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorSetExpectedSealDuration(p0 context.Context, p1 time.Duration) error {
	return s.Internal.SectorSetExpectedSealDuration(p0, p1)
}

func (s *StorageMinerStub) SectorSetExpectedSealDuration(p0 context.Context, p1 time.Duration) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorSetSealDelay(p0 context.Context, p1 time.Duration) error {
	return s.Internal.SectorSetSealDelay(p0, p1)
}

func (s *StorageMinerStub) SectorSetSealDelay(p0 context.Context, p1 time.Duration) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorStartSealing(p0 context.Context, p1 abi.SectorNumber) error {
	return s.Internal.SectorStartSealing(p0, p1)
}

func (s *StorageMinerStub) SectorStartSealing(p0 context.Context, p1 abi.SectorNumber) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorTerminate(p0 context.Context, p1 abi.SectorNumber) error {
	return s.Internal.SectorTerminate(p0, p1)
}

func (s *StorageMinerStub) SectorTerminate(p0 context.Context, p1 abi.SectorNumber) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorTerminateFlush(p0 context.Context) (*cid.Cid, error) {
	return s.Internal.SectorTerminateFlush(p0)
}

func (s *StorageMinerStub) SectorTerminateFlush(p0 context.Context) (*cid.Cid, error) {
	return nil, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorTerminatePending(p0 context.Context) ([]abi.SectorID, error) {
	return s.Internal.SectorTerminatePending(p0)
}

func (s *StorageMinerStub) SectorTerminatePending(p0 context.Context) ([]abi.SectorID, error) {
	return *new([]abi.SectorID), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsList(p0 context.Context) ([]abi.SectorNumber, error) {
	return s.Internal.SectorsList(p0)
}

func (s *StorageMinerStub) SectorsList(p0 context.Context) ([]abi.SectorNumber, error) {
	return *new([]abi.SectorNumber), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsListInStates(p0 context.Context, p1 []SectorState) ([]abi.SectorNumber, error) {
	return s.Internal.SectorsListInStates(p0, p1)
}

func (s *StorageMinerStub) SectorsListInStates(p0 context.Context, p1 []SectorState) ([]abi.SectorNumber, error) {
	return *new([]abi.SectorNumber), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsRefs(p0 context.Context) (map[string][]SealedRef, error) {
	return s.Internal.SectorsRefs(p0)
}

func (s *StorageMinerStub) SectorsRefs(p0 context.Context) (map[string][]SealedRef, error) {
	return *new(map[string][]SealedRef), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsStatus(p0 context.Context, p1 abi.SectorNumber, p2 bool) (SectorInfo, error) {
	return s.Internal.SectorsStatus(p0, p1, p2)
}

func (s *StorageMinerStub) SectorsStatus(p0 context.Context, p1 abi.SectorNumber, p2 bool) (SectorInfo, error) {
	return *new(SectorInfo), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsSummary(p0 context.Context) (map[SectorState]int, error) {
	return s.Internal.SectorsSummary(p0)
}

func (s *StorageMinerStub) SectorsSummary(p0 context.Context) (map[SectorState]int, error) {
	return *new(map[SectorState]int), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) SectorsUpdate(p0 context.Context, p1 abi.SectorNumber, p2 SectorState) error {
	return s.Internal.SectorsUpdate(p0, p1, p2)
}

func (s *StorageMinerStub) SectorsUpdate(p0 context.Context, p1 abi.SectorNumber, p2 SectorState) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageAddLocal(p0 context.Context, p1 string) error {
	return s.Internal.StorageAddLocal(p0, p1)
}

func (s *StorageMinerStub) StorageAddLocal(p0 context.Context, p1 string) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageAttach(p0 context.Context, p1 stores.StorageInfo, p2 fsutil.FsStat) error {
	return s.Internal.StorageAttach(p0, p1, p2)
}

func (s *StorageMinerStub) StorageAttach(p0 context.Context, p1 stores.StorageInfo, p2 fsutil.FsStat) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageBestAlloc(p0 context.Context, p1 storiface.SectorFileType, p2 abi.SectorSize, p3 storiface.PathType) ([]stores.StorageInfo, error) {
	return s.Internal.StorageBestAlloc(p0, p1, p2, p3)
}

func (s *StorageMinerStub) StorageBestAlloc(p0 context.Context, p1 storiface.SectorFileType, p2 abi.SectorSize, p3 storiface.PathType) ([]stores.StorageInfo, error) {
	return *new([]stores.StorageInfo), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageDeclareSector(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType, p4 bool) error {
	return s.Internal.StorageDeclareSector(p0, p1, p2, p3, p4)
}

func (s *StorageMinerStub) StorageDeclareSector(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType, p4 bool) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageDropSector(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType) error {
	return s.Internal.StorageDropSector(p0, p1, p2, p3)
}

func (s *StorageMinerStub) StorageDropSector(p0 context.Context, p1 stores.ID, p2 abi.SectorID, p3 storiface.SectorFileType) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageFindSector(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]stores.SectorStorageInfo, error) {
	return s.Internal.StorageFindSector(p0, p1, p2, p3, p4)
}

func (s *StorageMinerStub) StorageFindSector(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]stores.SectorStorageInfo, error) {
	return *new([]stores.SectorStorageInfo), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageInfo(p0 context.Context, p1 stores.ID) (stores.StorageInfo, error) {
	return s.Internal.StorageInfo(p0, p1)
}

func (s *StorageMinerStub) StorageInfo(p0 context.Context, p1 stores.ID) (stores.StorageInfo, error) {
	return *new(stores.StorageInfo), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageList(p0 context.Context) (map[stores.ID][]stores.Decl, error) {
	return s.Internal.StorageList(p0)
}

func (s *StorageMinerStub) StorageList(p0 context.Context) (map[stores.ID][]stores.Decl, error) {
	return *new(map[stores.ID][]stores.Decl), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageLocal(p0 context.Context) (map[stores.ID]string, error) {
	return s.Internal.StorageLocal(p0)
}

func (s *StorageMinerStub) StorageLocal(p0 context.Context) (map[stores.ID]string, error) {
	return *new(map[stores.ID]string), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageLock(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) error {
	return s.Internal.StorageLock(p0, p1, p2, p3)
}

func (s *StorageMinerStub) StorageLock(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageReportHealth(p0 context.Context, p1 stores.ID, p2 stores.HealthReport) error {
	return s.Internal.StorageReportHealth(p0, p1, p2)
}

func (s *StorageMinerStub) StorageReportHealth(p0 context.Context, p1 stores.ID, p2 stores.HealthReport) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageStat(p0 context.Context, p1 stores.ID) (fsutil.FsStat, error) {
	return s.Internal.StorageStat(p0, p1)
}

func (s *StorageMinerStub) StorageStat(p0 context.Context, p1 stores.ID) (fsutil.FsStat, error) {
	return *new(fsutil.FsStat), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) StorageTryLock(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) (bool, error) {
	return s.Internal.StorageTryLock(p0, p1, p2, p3)
}

func (s *StorageMinerStub) StorageTryLock(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 storiface.SectorFileType) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *StorageMinerStruct) WorkerConnect(p0 context.Context, p1 string) error {
	return s.Internal.WorkerConnect(p0, p1)
}

func (s *StorageMinerStub) WorkerConnect(p0 context.Context, p1 string) error {
	return xerrors.New("method not supported")
}

func (s *StorageMinerStruct) WorkerJobs(p0 context.Context) (map[uuid.UUID][]storiface.WorkerJob, error) {
	return s.Internal.WorkerJobs(p0)
}

func (s *StorageMinerStub) WorkerJobs(p0 context.Context) (map[uuid.UUID][]storiface.WorkerJob, error) {
	return *new(map[uuid.UUID][]storiface.WorkerJob), xerrors.New("method not supported")
}

func (s *StorageMinerStruct) WorkerStats(p0 context.Context) (map[uuid.UUID]storiface.WorkerStats, error) {
	return s.Internal.WorkerStats(p0)
}

func (s *StorageMinerStub) WorkerStats(p0 context.Context) (map[uuid.UUID]storiface.WorkerStats, error) {
	return *new(map[uuid.UUID]storiface.WorkerStats), xerrors.New("method not supported")
}

func (s *WalletStruct) WalletDelete(p0 context.Context, p1 address.Address) error {
	return s.Internal.WalletDelete(p0, p1)
}

func (s *WalletStub) WalletDelete(p0 context.Context, p1 address.Address) error {
	return xerrors.New("method not supported")
}

func (s *WalletStruct) WalletExport(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) {
	return s.Internal.WalletExport(p0, p1)
}

func (s *WalletStub) WalletExport(p0 context.Context, p1 address.Address) (*types.KeyInfo, error) {
	return nil, xerrors.New("method not supported")
}

func (s *WalletStruct) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return s.Internal.WalletHas(p0, p1)
}

func (s *WalletStub) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *WalletStruct) WalletImport(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) {
	return s.Internal.WalletImport(p0, p1)
}

func (s *WalletStub) WalletImport(p0 context.Context, p1 *types.KeyInfo) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *WalletStruct) WalletList(p0 context.Context) ([]address.Address, error) {
	return s.Internal.WalletList(p0)
}

func (s *WalletStub) WalletList(p0 context.Context) ([]address.Address, error) {
	return *new([]address.Address), xerrors.New("method not supported")
}

func (s *WalletStruct) WalletNew(p0 context.Context, p1 types.KeyType) (address.Address, error) {
	return s.Internal.WalletNew(p0, p1)
}

func (s *WalletStub) WalletNew(p0 context.Context, p1 types.KeyType) (address.Address, error) {
	return *new(address.Address), xerrors.New("method not supported")
}

func (s *WalletStruct) WalletSign(p0 context.Context, p1 address.Address, p2 []byte, p3 MsgMeta) (*crypto.Signature, error) {
	return s.Internal.WalletSign(p0, p1, p2, p3)
}

func (s *WalletStub) WalletSign(p0 context.Context, p1 address.Address, p2 []byte, p3 MsgMeta) (*crypto.Signature, error) {
	return nil, xerrors.New("method not supported")
}

func (s *WorkerStruct) AddPiece(p0 context.Context, p1 storage.SectorRef, p2 []abi.UnpaddedPieceSize, p3 abi.UnpaddedPieceSize, p4 storage.Data) (storiface.CallID, error) {
	return s.Internal.AddPiece(p0, p1, p2, p3, p4)
}

func (s *WorkerStub) AddPiece(p0 context.Context, p1 storage.SectorRef, p2 []abi.UnpaddedPieceSize, p3 abi.UnpaddedPieceSize, p4 storage.Data) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Enabled(p0 context.Context) (bool, error) {
	return s.Internal.Enabled(p0)
}

func (s *WorkerStub) Enabled(p0 context.Context) (bool, error) {
	return false, xerrors.New("method not supported")
}

func (s *WorkerStruct) Fetch(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType, p3 storiface.PathType, p4 storiface.AcquireMode) (storiface.CallID, error) {
	return s.Internal.Fetch(p0, p1, p2, p3, p4)
}

func (s *WorkerStub) Fetch(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType, p3 storiface.PathType, p4 storiface.AcquireMode) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) FinalizeSector(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) {
	return s.Internal.FinalizeSector(p0, p1, p2)
}

func (s *WorkerStub) FinalizeSector(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Info(p0 context.Context) (storiface.WorkerInfo, error) {
	return s.Internal.Info(p0)
}

func (s *WorkerStub) Info(p0 context.Context) (storiface.WorkerInfo, error) {
	return *new(storiface.WorkerInfo), xerrors.New("method not supported")
}

func (s *WorkerStruct) MoveStorage(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType) (storiface.CallID, error) {
	return s.Internal.MoveStorage(p0, p1, p2)
}

func (s *WorkerStub) MoveStorage(p0 context.Context, p1 storage.SectorRef, p2 storiface.SectorFileType) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Paths(p0 context.Context) ([]stores.StoragePath, error) {
	return s.Internal.Paths(p0)
}

func (s *WorkerStub) Paths(p0 context.Context) ([]stores.StoragePath, error) {
	return *new([]stores.StoragePath), xerrors.New("method not supported")
}

func (s *WorkerStruct) ProcessSession(p0 context.Context) (uuid.UUID, error) {
	return s.Internal.ProcessSession(p0)
}

func (s *WorkerStub) ProcessSession(p0 context.Context) (uuid.UUID, error) {
	return *new(uuid.UUID), xerrors.New("method not supported")
}

func (s *WorkerStruct) ReleaseUnsealed(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) {
	return s.Internal.ReleaseUnsealed(p0, p1, p2)
}

func (s *WorkerStub) ReleaseUnsealed(p0 context.Context, p1 storage.SectorRef, p2 []storage.Range) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Remove(p0 context.Context, p1 abi.SectorID) error {
	return s.Internal.Remove(p0, p1)
}

func (s *WorkerStub) Remove(p0 context.Context, p1 abi.SectorID) error {
	return xerrors.New("method not supported")
}

func (s *WorkerStruct) SealCommit1(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 abi.InteractiveSealRandomness, p4 []abi.PieceInfo, p5 storage.SectorCids) (storiface.CallID, error) {
	return s.Internal.SealCommit1(p0, p1, p2, p3, p4, p5)
}

func (s *WorkerStub) SealCommit1(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 abi.InteractiveSealRandomness, p4 []abi.PieceInfo, p5 storage.SectorCids) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) SealCommit2(p0 context.Context, p1 storage.SectorRef, p2 storage.Commit1Out) (storiface.CallID, error) {
	return s.Internal.SealCommit2(p0, p1, p2)
}

func (s *WorkerStub) SealCommit2(p0 context.Context, p1 storage.SectorRef, p2 storage.Commit1Out) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) SealPreCommit1(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 []abi.PieceInfo) (storiface.CallID, error) {
	return s.Internal.SealPreCommit1(p0, p1, p2, p3)
}

func (s *WorkerStub) SealPreCommit1(p0 context.Context, p1 storage.SectorRef, p2 abi.SealRandomness, p3 []abi.PieceInfo) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) SealPreCommit2(p0 context.Context, p1 storage.SectorRef, p2 storage.PreCommit1Out) (storiface.CallID, error) {
	return s.Internal.SealPreCommit2(p0, p1, p2)
}

func (s *WorkerStub) SealPreCommit2(p0 context.Context, p1 storage.SectorRef, p2 storage.PreCommit1Out) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Session(p0 context.Context) (uuid.UUID, error) {
	return s.Internal.Session(p0)
}

func (s *WorkerStub) Session(p0 context.Context) (uuid.UUID, error) {
	return *new(uuid.UUID), xerrors.New("method not supported")
}

func (s *WorkerStruct) SetEnabled(p0 context.Context, p1 bool) error {
	return s.Internal.SetEnabled(p0, p1)
}

func (s *WorkerStub) SetEnabled(p0 context.Context, p1 bool) error {
	return xerrors.New("method not supported")
}

func (s *WorkerStruct) StorageAddLocal(p0 context.Context, p1 string) error {
	return s.Internal.StorageAddLocal(p0, p1)
}

func (s *WorkerStub) StorageAddLocal(p0 context.Context, p1 string) error {
	return xerrors.New("method not supported")
}

func (s *WorkerStruct) TaskDisable(p0 context.Context, p1 sealtasks.TaskType) error {
	return s.Internal.TaskDisable(p0, p1)
}

func (s *WorkerStub) TaskDisable(p0 context.Context, p1 sealtasks.TaskType) error {
	return xerrors.New("method not supported")
}

func (s *WorkerStruct) TaskEnable(p0 context.Context, p1 sealtasks.TaskType) error {
	return s.Internal.TaskEnable(p0, p1)
}

func (s *WorkerStub) TaskEnable(p0 context.Context, p1 sealtasks.TaskType) error {
	return xerrors.New("method not supported")
}

func (s *WorkerStruct) TaskTypes(p0 context.Context) (map[sealtasks.TaskType]struct{}, error) {
	return s.Internal.TaskTypes(p0)
}

func (s *WorkerStub) TaskTypes(p0 context.Context) (map[sealtasks.TaskType]struct{}, error) {
	return *new(map[sealtasks.TaskType]struct{}), xerrors.New("method not supported")
}

func (s *WorkerStruct) UnsealPiece(p0 context.Context, p1 storage.SectorRef, p2 storiface.UnpaddedByteIndex, p3 abi.UnpaddedPieceSize, p4 abi.SealRandomness, p5 cid.Cid) (storiface.CallID, error) {
	return s.Internal.UnsealPiece(p0, p1, p2, p3, p4, p5)
}

func (s *WorkerStub) UnsealPiece(p0 context.Context, p1 storage.SectorRef, p2 storiface.UnpaddedByteIndex, p3 abi.UnpaddedPieceSize, p4 abi.SealRandomness, p5 cid.Cid) (storiface.CallID, error) {
	return *new(storiface.CallID), xerrors.New("method not supported")
}

func (s *WorkerStruct) Version(p0 context.Context) (Version, error) {
	return s.Internal.Version(p0)
}

func (s *WorkerStub) Version(p0 context.Context) (Version, error) {
	return *new(Version), xerrors.New("method not supported")
}

func (s *WorkerStruct) WaitQuiet(p0 context.Context) error {
	return s.Internal.WaitQuiet(p0)
}

func (s *WorkerStub) WaitQuiet(p0 context.Context) error {
	return xerrors.New("method not supported")
}

var _ ChainIO = new(ChainIOStruct)
var _ Common = new(CommonStruct)
var _ FullNode = new(FullNodeStruct)
var _ Gateway = new(GatewayStruct)
var _ Signable = new(SignableStruct)
var _ StorageMiner = new(StorageMinerStruct)
var _ Wallet = new(WalletStruct)
var _ Worker = new(WorkerStruct)
