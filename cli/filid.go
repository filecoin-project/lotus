package cli

import (
	"encoding/hex"

	"github.com/urfave/cli/v2"
	"golang.org/x/xerrors"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/crypto"

	"github.com/filecoin-project/lotus/chain/types"
)

const EVG = "ICAg"
const EVG_AUTHHDR = "FIL-SPID-V0"

var NonInteractiveAuthCmd = &cli.Command{
	Name:      "fil-id",
	Usage:     "Generate a non-interactive authentication token which can be used to establish identity",
	ArgsUsage: "<signing address> <hexMessage>",
	Description: `The token generated by this command can be used to authenticate against various services in the ecosystem.
Currently, it generates a token for slingshot-evegreen data onboarding program.
Depending on the use case, this command can be expanded to generate specific tokens for other systems as well`,

	Subcommands: []*cli.Command{
		NonInteractiveAuthEVGCmd,
	},
}

var NonInteractiveAuthEVGCmd = &cli.Command{
	Name:      "evg",
	Usage:     "Generate a non-interactive authentication token for slingshot-evergreen",
	ArgsUsage: "<minerId> or <wallet address>",
	Flags: []cli.Flag{
		&cli.BoolFlag{
			Name:  "owner-address",
			Usage: "owner address for the given miner will be used to sign the message",
		},
		&cli.BoolFlag{
			Name:  "worker-address",
			Usage: "owner address for the given miner will be used to sign the message",
		},
		&cli.StringFlag{
			Name:  "wallet-address",
			Usage: "wallet address provided as argument will be used to sign the message",
		},
	},

	Action: func(cctx *cli.Context) error {
		napi, closer, err := GetFullNodeAPI(cctx)
		if err != nil {
			return err
		}
		defer closer()

		ctx := ReqContext(cctx)

		afmt := NewAppFmt(cctx.App)

		if cctx.IsSet("owner-address") && cctx.IsSet("worker-address") {
			return xerrors.New("either --owner-address or --worker-address address can be used but not both at once")
		}
		if !cctx.IsSet("owner-address") && !cctx.IsSet("worker-address") {
			return xerrors.New("must specify --owner-address or --worker-address")
		}

		head, err := napi.ChainHead(ctx)
		if err != nil {
			return xerrors.Errorf("failed to get chain head: %w", err)
		}

		finality := abi.ChainEpoch(uint64(head.Height()) - 900)
		ftipset, err := napi.ChainGetTipSetByHeight(ctx, finality, types.EmptyTSK)
		if err != nil {
			return xerrors.Errorf("failed to get finality tipset: %w", err)
		}
		beacon, err := napi.BeaconGetEntry(ctx, head.Height())
		if err != nil {
			return xerrors.Errorf("failed to get DRAND beacon: %w", err)
		}
		beaconhex := hex.EncodeToString(beacon.Data)

		// Add a constant to BeaconEntry
		hmsg := EVG + beaconhex

		msg, err := hex.DecodeString(hmsg)
		if err != nil {
			return xerrors.Errorf("failed to encode message: %w", err)
		}

		maddr, err := address.NewFromString(cctx.Args().First())
		if err != nil {
			return xerrors.Errorf("failed to get miner address from argument: %w", err)
		}

		// Get miner info for last finality
		minfo, err := napi.StateMinerInfo(ctx, maddr, ftipset.Key())
		if err != nil {
			return xerrors.Errorf("failed to get miner info: %w", err)
		}

		worker := minfo.Worker
		var sig *crypto.Signature

		if cctx.IsSet("wallet-address") {
			addr, err := address.NewFromString(cctx.Args().First())
			if err != nil {
				return xerrors.Errorf("failed to get address from argument: %w", err)
			}
			sig, err = napi.WalletSign(ctx, addr, msg)
			if err != nil {
				return xerrors.Errorf("failed to get sign message with wallet key: %w", err)
			}
		} else {
			sig, err = napi.WalletSign(ctx, worker, msg)
			if err != nil {
				return xerrors.Errorf("failed to get sign message with worker address key: %w", err)
			}
		}

		sigBytes := append([]byte{byte(sig.Type)}, sig.Data...)

		afmt.Printf("%s %d;%s;%s\n", EVG_AUTHHDR, head.Height(), maddr, hex.EncodeToString(sigBytes))
		return nil
	},
}
