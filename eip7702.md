

### Progress Status (EIP‑7702 in Lotus)

Completed (Phase‑1 front‑half):
- Type `0x04` parsing/encoding with `authorizationList` and dispatch.
- RPC views include `authorizationList`; receipt echo scaffold in place.
- Send‑path scaffolding: feature flag (`eip7702_enabled`), `DelegatorActorAddr`, CBOR params encoder.
- Delegator scaffold: tuple decoder, static validations (chainId, yParity, low‑s), state helper to apply mappings with nonce checks.
- Focused tests: RLP round‑trip, guards, CBOR shape, feature‑flag path, delegator validations and state application.

Remaining (Phase‑2 back‑half):
- Delegator actor: real state (HAMT), authority nonce tracking, `ApplyDelegations` (validate → write → bump → gas/refund).
- EVM runtime: execute delegate code on EOA with empty code when mapping present.
- Send‑path: flip 7702 to call Delegator with CBOR tuples once actor deployed.
- Gas estimation: implement constants and simulated writes/refunds.
- Mempool policy: per‑EOA caps and cross‑account nonce invalidation.
- RPC/logs: ensure delegate execution context and bloom correctness.

### Lotus vs FVM summary

- Lotus/Go (done): 0x04 parsing/encoding; `authorizationList` in RPC/receipts; CBOR params; send‑path targets Delegator method (dev/test flag); mempool eviction + per‑EOA cap gated by network version; intrinsic gas overhead scaffold; tuple decode/validation + state apply helpers; tests + observability; docs.
- Lotus/Go (left): align gas/refund constants in estimation with actor; end‑to‑end tests after actor/runtime land; receipt/log polish only if FVM attribution needs it; remove guardrails after network upgrade.
- FVM/Rust (left): Delegator actor (HAMT state, ApplyDelegations with ecrecover, nonce checks, gas/refunds); EVM runtime delegation for EOAs with empty code; receipts/logs attribution; protocol gating at the network upgrade; conformance/integration tests.

### 2.5 Activation & Flags (Lotus)

- Activation: EIP‑7702 behavior is gated by network version; features become active at/after the targeted upgrade (no user config required).
- Build tag: `eip7702_enabled` remains for development/testing of the send‑path.
- Env (dev/test): `LOTUS_ETH_7702_DELEGATOR_ADDR` can set the Delegator actor address when the feature flag is enabled.

Notes:
- Intrinsic gas overhead for 7702 is currently scaffolded in Lotus for estimation; final constants/refunds are provided by the actor/FVM.
- Receipts echo `authorizationList`; delegated execution attribution is finalized once FVM wiring lands.

---

### 1. Introduction

#### 1.1 Why Lotus Needs EIP‑7702 Support

From a developer’s perspective, the Ethereum ecosystem is rapidly moving toward account abstraction and richer wallet functionality. Externally owned accounts (EOAs) have traditionally been limited to sending value or simple contract calls, leaving advanced features—such as batched operations, sponsored gas payments and granular permissions—to smart contract wallets. EIP‑7702 bridges this gap by allowing an EOA to delegate its execution to a smart‑contract account through a new transaction type. This means:

* **Improved user experience**: Workflows like “approve and spend” can be compressed into a single transaction. Users won’t need to install specialised smart‑contract wallets to enjoy the benefits of batching and sponsorship.
    
* **Simpler developer tooling**: DApp developers can offer streamlined interactions without maintaining separate code paths for EOAs and contract wallets. Signing flows remain familiar, as EIP‑7702 uses standard secp256k1 signatures for both the outer transaction and each delegation authorisation.
    
* **Backward compatibility**: EIP‑7702 leverages the existing EIP‑2718 typed transaction framework and EIP‑2930 access lists, meaning existing JSON‑RPC clients can transmit and decode these transactions with minimal change once the new type is recognised.
    

For the Filecoin Lotus client, adopting EIP‑7702 ensures that Ethereum‑style tools and wallets behave consistently across chains. Developers targeting both networks can rely on the same account‑abstraction primitives, reducing cognitive load and ensuring that cross‑ecosystem libraries work out of the box. Without this support, Lotus would lag behind Ethereum’s evolving UX standards, fragmenting developer experience and discouraging adoption of the Filecoin EVM.

#### 1.2 Purpose of This Document

This design document lays the groundwork for integrating EIP‑7702 into Lotus. It aims to:

* Summarise the EIP‑7702 specification with a focus on how it impacts developers who submit, decode and trace transactions.
    
* Map the current Lotus architecture to the requirements of EIP‑7702, identifying which components—parsers, RPC handlers, message conversion logic and actors—need adaptation.
    
* Propose a high‑level design that preserves existing APIs while introducing the new transaction type, balancing ease of use for developers with protocol correctness and security.
    
* Surface open questions and risks early, so downstream developers and reviewers can comment before implementation begins.
    

The overarching goal is to ensure that, from a developer’s viewpoint, adding EIP‑7702 support to Lotus feels like a natural extension of the existing Eth‑RPC and EVM functionality—no mysterious flags or bespoke endpoints, just another transaction type that “just works.”

#### 1.3 Scope

Phase 1 focuses on research and high‑level design only. We will **not** write code at this stage; rather, we will explore the specification, inspect Lotus internals and draft an architecture that guides implementation. Subsequent phases will address concrete development tasks such as parsing, message conversion, actor modifications, API updates and testing.

* * *

* * *

### 2. Overview of EIP‑7702

EIP‑7702, titled “Set Code for EOAs,” introduces a new typed transaction that allows externally owned accounts to adopt smart‑contract functionality without migrating to a full contract wallet. From a developer’s perspective, it extends the familiar EIP‑1559/EIP‑4844 transaction model with a few additional fields and rules, making it easy to integrate into existing tooling.

#### 2.1 What the EIP Proposes

At its core, EIP‑7702 defines a new transaction type (`0x04`) and a payload format that includes an **authorization list**. Each entry in this list is a signature by another EOA (“authority”) giving permission to set its code to a _delegation indicator_ pointing at a smart contract’s code. The transaction is signed twice: once by the sender (as usual) and once for each authorising account. The EIP thus decouples who pays for the transaction (the sender) from which accounts get updated (the authorities). The specification states that the set‑code transaction is RLP‑encoded as:

```
rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas,
     gas_limit, destination, value, data, access_list,
     authorization_list, signature_y_parity, signature_r, signature_s])
```

with `authorization_list` being an array of `[chain_id, address, nonce, y_parity, r, s]` tuples[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=rlp%28,access_list%2C%20authorization_list%2C%20signature_y_parity%2C%20signature_r%2C%20signature_s). All outer fields follow the semantics of EIP‑4844 transactions[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20fields%20,null%20destination%20is%20not%20valid), so developers can reuse existing code for fee handling, nonce management and access lists.

#### 2.2 Developer‑Focused Features

EIP‑7702 unlocks several capabilities that directly improve developer and end‑user experience:

* **Atomic batching**: Developers can pack multiple contract calls into a single transaction from an EOA, without worrying about the two‑transaction “approve then call” pattern. This reduces user friction and eliminates intermediate pending states.
    
* **Sponsored transactions**: A sponsor can pay gas on behalf of an EOA by including its own authorisation in the `authorization_list`. Tooling can support gasless interactions by creating and signing an authorisation for the EOA, while the sponsor signs and sends the outer transaction.
    
* **Fine‑grained permissions**: Each authorising account can sign over specific parameters (chain ID, target address, expected nonce), enabling limited scopes—such as spending only ERC‑20 tokens or calling only a specific contract—without granting full control.
    

Because EIP‑7702 uses standard secp256k1 signatures and the familiar RLP structure, integrating these features into existing wallets, SDKs and transaction relayers is straightforward. Developers can think of the new transaction as a superset of the EIP‑1559 structure, with an extra array of delegations and corresponding signatures.

#### 2.3 Transaction Structure in Detail

For engineers implementing client support, understanding each field is essential:

* **Type tag (`0x04`)**: Signals a set‑code transaction; allows backward‑compatibility via the EIP‑2718 typed‑transaction envelope[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Specification).
    
* **Outer fields** (`chain_id`, `nonce`, `max_priority_fee_per_gas`, `max_fee_per_gas`, `gas_limit`, `destination`, `value`, `data`, `access_list`): Identical to EIP‑4844 semantics[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20fields%20,null%20destination%20is%20not%20valid). A null `destination` is explicitly disallowed[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20fields%20,null%20destination%20is%20not%20valid), simplifying contract deployments.
    
* **Authorization list**: Must contain at least one tuple; each tuple encodes the target chain, the contract address whose code should be delegated to, the expected nonce of the authority and a secp256k1 signature over `keccak256(MAGIC || rlp([chain_id, address, nonce]))`[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following). Clients must reject transactions with an empty list or out‑of‑range fields[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20,is%20zero).
    
* **Outer signature** (`signature_y_parity`, `signature_r`, `signature_s`): Signs the entire RLP‑encoded payload prefixed with the type byte[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20,TransactionPayload), just like EIP‑1559.
    

Because the outer and inner signatures use the same cryptographic primitives, libraries that already support EIP‑1559 can be extended to build and verify EIP‑7702 transactions with minimal changes.

#### 2.4 Gas and Cost Model

Gas costs remain intuitive for developers. The intrinsic gas is computed as:

* The base EIP‑2930 cost: `21000` plus calldata costs and access‑list overhead[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=).
    
* An additional `PER_EMPTY_ACCOUNT_COST * len(authorization_list)` gas charge[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=).
    

On the refund side, if an authorisation sets a delegation on an empty account, the EIP grants a partial refund of `PER_EMPTY_ACCOUNT_COST − PER_AUTH_BASE_COST` gas[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=7.%20Add%20%60PER_EMPTY_ACCOUNT_COST%20,This%20is%20a%20delegation%20indicator). These constants are public parameters of the proposal[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Specification), so developers can accurately predict costs. When retrieving code for delegation, each cold account access incurs the usual `COLD_ACCOUNT_READ_COST` (2600 gas) and adds the account to the warm set, while warm accesses cost only 100 gas[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20transaction%20sender%20will%20pay,regardless%20of%20validity%20or%20duplication).

From a tooling standpoint, this means gas estimators must factor in both the number of authorisations and the potential cost of following delegation pointers. Wallet UIs should display the total authorisation count and warn users that each additional signature will increase their fee.

#### 2.5 Differences from Existing Transaction Types

For developers familiar with EIP‑1559 (type `0x02`) and EIP‑2930 (type `0x01`), EIP‑7702 introduces two key differences:

1. **Multi‑signature structure**: The presence of an authorisation list requires clients to handle nested signatures. Signing flows must generate a separate signature for each `authority` and embed them into the transaction before signing the outer payload.
    
2. **Persistent code delegation**: Unlike contract deployments, which execute initcode and permanently set code for a new address, EIP‑7702 writes a delegation indicator (`0xef0100 || address`) to an existing EOA and increments its nonce[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=7.%20Add%20%60PER_EMPTY_ACCOUNT_COST%20,by%20one). The actual code lives elsewhere and can be updated by sending another set‑code transaction. This mechanism creates a hybrid between EOAs and contract accounts, which clients must recognise when tracing call stacks, reading storage or computing balances.
    

Despite these differences, the EIP emphasises backwards compatibility by leaving the outer fee market and access list semantics untouched. Tools that generically handle typed transactions should therefore require only targeted updates to support the new `authorization_list` field.

#### 2.6 Security Considerations

For client developers, correctly implementing the EIP’s security rules is critical:

* **Field bounds**: Clients must validate that `auth.chain_id`, `auth.nonce`, `auth.address`, `auth.y_parity`, `auth.r` and `auth.s` fit within prescribed ranges[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20,is%20zero), rejecting malformed transactions early.
    
* **Low‑s enforcement**: Each authorisation signature must satisfy the low‑`s` condition (`s ≤ n/2`) as per EIP‑2[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following).
    
* **Code emptiness and nonce checks**: Before writing a delegation, clients must verify the authority’s account code is either empty or already delegated, and that its nonce matches the supplied `auth.nonce`[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=5,This%20is%20a%20delegation%20indicator). Failing to enforce this could allow replay attacks or accidental code overwrites.
    
* **Non‑rollback**: Delegation indicators remain even if the subsequent call reverts[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Note%2C%20if%20transaction%20execution%20results,indicators%20is%20not%20rolled%20back), so clients must update account state before transaction execution.
    
* **Prohibition on nested delegations**: Clients must follow only the first delegation and ignore chains or loops[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=) to avoid unbounded recursion.
    

Addressing these considerations up front reduces the risk of subtle bugs that could erode developer trust. Well‑designed SDKs should surface helpful error messages when invalid authorisations are detected, guiding developers toward correct usage.

* * *

With this overview, developers can appreciate both the mechanics of EIP‑7702 and its benefits for user experience. Subsequent sections will map these requirements onto Lotus’s codebase and propose concrete design changes.



### 3. Current Lotus Architecture

Lotus provides an Ethereum JSON‑RPC layer that allows Ethereum wallets and tooling to interact with the Filecoin EVM. Before adding EIP‑7702, it’s important to understand how this layer currently processes Ethereum‑style transactions end to end—from RPC calls to Filecoin message execution—and where code and state are managed. The following subsections dissect the major components and their interactions.

#### 3.1 Eth API Entry Points

At the front of the pipeline is the **gateway** package, which implements JSON‑RPC compatibility. Two primary proxy files are used:

* **`gateway/proxy_eth_v1.go`** and **`gateway/proxy_v2.go`** expose methods such as `eth_sendRawTransaction`, `eth_call`, `eth_getTransactionReceipt`, etc. These proxies perform minimal work: they parse JSON parameters, enforce rate limits, and forward calls to the full node’s internal API. For example, `proxy_eth_v1.go`’s `EthSendRawTransaction` method simply calls the server’s `EthSendRawTransaction` and returns the resulting hash[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/gateway/proxy_eth_v1.go#:~:text=return%20nil%2C%20err%20). The proxies therefore act as a thin compatibility layer and do not parse or validate transaction bytes themselves.
    
* **`gateway/eth_sub.go`** manages subscription sinks for event logs. It maintains queues of log messages and distributes them to subscribers[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/gateway/eth_sub.go#:~:text=type%20EthSubHandler%20struct%20,ethtypes.EthSubscriptionResponse%29%20error). Because EIP‑7702 can cause EOAs to emit contract logs, this component will become more relevant, but currently it is agnostic to transaction types.
    

On the server side, these proxies delegate to the **full node’s Eth API implementation**, found under `node/impl/eth`. Here, methods are organised by function (sending, basic info, gas, transactions, events, filecoin mapping, etc.), each implemented in a separate file.

#### 3.2 Transaction Parsing and Data Types

When a client submits a raw RLP‑encoded transaction via `eth_sendRawTransaction`, the call eventually reaches `node/impl/eth/send.go`. The core flow looks like this:

1. **Hex decoding and trust handling**: `EthSendRawTransaction` takes the hex string, decodes it into bytes and calls an internal helper `ethSendRawTransaction` with a `sendType` (Trusted or Untrusted). The difference determines whether the message is pushed via `MpoolPush` or `MpoolPushUntrusted`[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/node/impl/eth/send.go#:~:text=func%20%28e%20,EmptyEthHash%2C%20err).
    
2. **Parsing**: `ethSendRawTransaction` calls `ethtypes.ParseEthTransaction(rawBytes)`[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/node/impl/eth/send.go#:~:text=func%20%28e%20,EmptyEthHash%2C%20err). The parser examines the first byte of the RLP payload to identify the transaction type (legacy, EIP‑155, EIP‑1559) and dispatches to `parseHomesteadTx`, `parseEIP155LegacyTx` or `parseEip1559Tx` accordingly[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_transactions.go#:~:text=func%20ParseEthTransaction%28data%20,). Each parser returns an object implementing the `EthTransaction` interface.
    
3. **Conversion to Filecoin message**: Once parsed, `ethSendRawTransaction` calls `ToSignedFilecoinMessage()` on the `EthTransaction` instance. Internally, this invokes `ToUnsignedFilecoinMessage()` (setting fields like `To`, `From`, `Value`, `GasLimit`, `GasFeeCap`, `GasPremium`, `Nonce` and `Params`) and then signs it with the recovered Ethereum signature. The result is a `types.SignedMessage` ready for the Filecoin message pool.
    
4. **Message pool and chain indexer**: The signed message is submitted to the message pool via `MpoolPush{Untrusted}`, and the transaction is indexed in the chain indexer so that `eth_getTransactionByHash` and `eth_getTransactionReceipt` can later retrieve it.
    

The **`eth_transactions.go`** file defines the `EthTransaction` interface that all concrete transaction types must implement. The methods include:

* `ToUnsignedFilecoinMessage()`, `ToRlpUnsignedMsg()`, `ToRlpSignedMsg()`, `TxHash()`, `Signature()`, `Sender()`, `Type()`, `ToVerifiableSignature()`, `ToEthTx()`[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_transactions.go#:~:text=%2F%2F%20EthTransaction%20defines%20the%20interface,types.SignedMessage%29%20%28EthTx%2C%20error%29).
    

Concrete implementations reside in separate files:

* **`eth_1559_transactions.go`** defines `Eth1559TxArgs`, representing EIP‑1559 transactions. It builds a Filecoin message by mapping `max_fee_per_gas` to `GasFeeCap`, `max_priority_fee_per_gas` to `GasPremium`, and so on[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_1559_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29). It encodes the transaction as a type‑`0x02` list and computes the transaction hash by hashing the encoded data[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_1559_transactions.go#:~:text=func%20parseEip1559Tx%28data%20%5B%5Dbyte%29%20%28,d%22%2C%20EIP1559TxType%29).
    
* **`eth_legacy_155_transactions.go`** defines `EthLegacy155TxArgs`, wrapping `EthLegacyHomesteadTxArgs` and adding the chain ID for replay protection[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_legacy_155_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29). It handles EIP‑155 semantics, including repeated chain ID fields in the RLP encoding and adjusted `v` values.
    
* **`eth_legacy_homestead_transactions.go`** defines `EthLegacyHomesteadTxArgs` for pre‑EIP‑155 legacy transactions, mapping simple fields like gas price and gas limit to Filecoin equivalents[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_legacy_homestead_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29).
    

The **`eth_types.go`** file provides lower‑level types (e.g. `EthUint64`, `EthBigInt`, `EthBytes`, `EthAddress`, `EthHash`, `EthTx`) with JSON marshalling functions[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_types.go#:~:text=type%20EthUint64%20uint64). The `EthTx` struct is used to represent a decoded transaction in RPC responses; it contains chain ID, nonce, hash, `From` and `To` addresses, value, gas, fee fields, type and signature values.

For developers building on top of Lotus, these abstractions mean you rarely need to think about RLP encoding or signature recovery; the parser returns a Go object with high‑level methods that can be converted to a Filecoin message with a single call. However, extending support to new transaction types (like EIP‑7702) requires implementing the full interface and carefully mapping its semantics to Filecoin messages.

#### 3.3 Message Conversion and Execution

After parsing, the transaction is converted into a Filecoin `types.Message`, signed and pushed to the message pool. Key points in this conversion include:

* **Address resolution**: The `FilecoinAddressToEthAddress` and `EthAddressToFilecoinAddress` methods in `node/impl/eth/filecoin.go` convert between Ethereum hex addresses and Filecoin ID or delegated addresses[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/node/impl/eth/filecoin.go#:~:text=ts%2C%20err%20%3A%3D%20e,wrap%2C%20to%20preserve%20ErrNullRound). When building the message, `ToUnsignedFilecoinMessage` must resolve `From` and `To` addresses to Filecoin format, possibly via the state manager to handle robust addresses.
    
* **Method and parameters**: Depending on whether the Ethereum transaction is a simple value transfer, contract call or contract creation, `getFilecoinMethodInfo` and `getEthParamsAndRecipient` decide which Filecoin actor method to invoke and how to pack the calldata into the message’s `Params` field. For contract calls, the message usually targets the EVM actor; for native FIL transfers, it calls the built‑in send method.
    
* **Signature application**: The `Signature()` method on `EthTransaction` returns `(r, s, v)`, which are converted into the appropriate Filecoin signature type (SECP256K1). `ToSignedFilecoinMessage` computes the CID and wraps the unsigned message in a `SignedMessage`.
    
* **Gas fields**: `GasLimit`, `GasFeeCap` and `GasPremium` (priority fee) are set on the Filecoin message using the values from the Ethereum transaction. The gas estimator uses these fields to determine whether the message has sufficient funds.
    

Once in the message pool, the message is executed by the Filecoin VM during block production. Lotus uses the **EVM actor** (`chain/actors/builtin/evm`) to run Ethereum bytecode. The `evm.go` file implements helpers `Load` and `MakeState` to initialise and fetch actor state across versions[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/actors/builtin/evm/evm.go#:~:text=func%20Load%28store%20adt.Store%2C%20act%20,s%22%2C%20name%29). Contract creation messages store code and initial storage for new EVM actors; contract calls load the existing code and execute it with the provided calldata.

EOAs in Filecoin are represented as simple account actors with empty code. They cannot execute code or delegate to another contract. This is why supporting EIP‑7702 will require changes at this layer: we will need a mechanism to mark an EOA as delegated and point it at another contract’s code.

#### 3.4 Transaction Retrieval and Events

Once a message is mined, several API methods expose its status and results:

* **`node/impl/eth/transaction.go`** implements `EthBlockNumber`, `EthGetTransactionByHash`, `EthGetBlockTransactionCountByNumber`, `EthGetTransactionReceipt`, etc. When retrieving a transaction, Lotus looks up the signed message via the chain indexer, then converts it back into an `EthTx` struct using `EthTransactionFromSignedFilecoinMessage`. Receipts are constructed with status, gas used, logs, `contractAddress` and `logsBloom`. These methods currently understand only legacy, EIP‑155 and EIP‑1559 transaction types.
    
* **`node/impl/eth/events.go`** implements `EthGetLogs`, `EthNewFilter`, `EthGetFilterChanges`, etc. It interfaces with the block indexer and the EVM actor’s log emission to filter and return logs to subscribers[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/node/impl/eth/events.go#:~:text=func%20%28e%20,stateManager%29).
    

For developers, these APIs provide the same interface as a standard Ethereum node. This means debuggers, explorers and wallets can query transactions and logs from Lotus without modification. Supporting EIP‑7702 will require the receipt and log generation code to recognise delegation events and possibly augment the `EthTx` struct with the `authorization_list` for full fidelity.

#### 3.5 Relevant Files Recap

For quick reference, the major files involved in the current pipeline are:

* `gateway/proxy_eth_v1.go`, `gateway/proxy_v2.go` – RPC proxies forwarding eth_* calls to the full node.
    
* `node/impl/eth/send.go` – Parses raw transactions, converts them to Filecoin messages and pushes them to the message pool.
    
* `node/impl/eth/api.go` – Defines the Eth API interfaces and injects dependencies.
    
* `node/impl/eth/basic.go`, `gas.go`, `filecoin.go`, `transaction.go`, `events.go` – Implement RPC methods for chain info, gas estimation, address conversion, transaction retrieval and logs.
    
* `chain/types/ethtypes/eth_transactions.go` – Defines the `EthTransaction` interface and dispatches parsing.
    
* `chain/types/ethtypes/eth_1559_transactions.go`, `eth_legacy_155_transactions.go`, `eth_legacy_homestead_transactions.go` – Concrete transaction types with conversion logic.
    
* `chain/types/ethtypes/eth_types.go` – Base Ethereum types, including `EthTx`.
    
* `chain/actors/builtin/evm/evm.go` – Loads EVM actor state and provides helper functions.
    

Understanding how these components interact is crucial for implementing EIP‑7702. Each layer—from RPC to parsing to message construction and VM execution—will need to be touched, but a thorough grasp of the current flow will allow us to introduce the new transaction type without destabilising existing functionality.


### 4. Impact Analysis of EIP‑7702 on Lotus

With a solid understanding of both the EIP‑7702 specification and the current Lotus architecture, we can identify how the proposal will ripple through the system. The following subsections map the EIP’s requirements onto specific Lotus components, highlighting where changes are necessary and where existing abstractions can be reused. Throughout, we keep developer experience in mind: the goal is for these changes to feel like a natural extension of existing APIs rather than a bolt‑on.

#### 4.1 New Transaction Type Recognition

**Where it matters**: `chain/types/ethtypes/eth_transactions.go` and `node/impl/eth/send.go`.

The `ParseEthTransaction` function currently distinguishes only between legacy (no type tag), EIP‑155 (type `0x01` but actually still legacy with chain ID), and EIP‑1559 (type `0x02`). To support EIP‑7702, it must inspect the first byte of the RLP payload (or the typed‑transaction envelope) and dispatch type `0x04` to a new `parseEIP7702Tx` parser.

Developers will expect that simply constructing a transaction with `type: '0x04'` and an `authorizationList` field will result in a valid submission. From their perspective, nothing else should change: existing wallets and SDKs that support typed transactions can map to Lotus once the new type is implemented. Internally, we need to:

* Introduce a new `Eth7702TxArgs` struct that holds all outer fields plus the `authorization_list` and implements the `EthTransaction` interface.
    
* Implement methods such as `ToRlpUnsignedMsg()`, `ToRlpSignedMsg()`, `TxHash()` and `Signature()` using the EIP‑7702 rules (e.g. signing `keccak256(0x04 || RLP(payload))`).
    
* Ensure `Type()` returns `4`.
    

Without these changes, the parsing function will reject EIP‑7702 transactions as invalid, leading to confusing error messages for developers.

#### 4.2 Data Model Changes

**Where it matters**: `chain/types/ethtypes/eth_types.go`.

The `EthTx` struct currently used for RPC responses lacks a field for the `authorization_list`. To provide full fidelity to clients (e.g., explorers, wallets, debuggers), this struct must be extended to include:

* A field `AuthorizationList` (or similar) containing a slice of `EthAuthorization` objects. Each object should mirror the six fields in the EIP’s tuples.
    
* Appropriate JSON marshaling and unmarshaling tags so that clients can decode/encode the field as a list of nested arrays (matching the RLP order).
    
* Constants and helper functions to identify the new transaction type; e.g. `const EthTransactionTypeSetCode = 0x04`.
    

Library authors rely on `EthTx` to decode and display transaction details. If the field is omitted, they will lose access to crucial data and may misinterpret EIP‑7702 transactions as unknown types. However, adding fields can break binary compatibility with existing code that uses struct literals; to minimise disruption, these additions should preserve existing field order and be optional (`omitempty`).

#### 4.3 Signature and Nonce Verification

**Where it matters**: `eth_transactions.go`, `eth_7702_transactions.go` (new), `node/impl/eth/send.go`.

EIP‑7702 requires two levels of signature verification:

1. The **outer transaction signature**, which authenticates the sender and ensures the transaction cannot be replayed on another chain or with a different nonce. This is similar to EIP‑1559.
    
2. Each **authorisation tuple signature**, which must sign over `keccak256(MAGIC || rlp([auth_chain_id, auth_address, auth_nonce]))`[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following). Additionally, clients must enforce:
    
    * `s ≤ n/2` (low‑s condition)[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following).
        
    * `auth_nonce < 2^64`[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=1,This%20is%20a%20delegation%20indicator).
        
    * `auth_chain_id` is either zero or the current chain ID[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following).
        
    * The authority’s account nonce equals `auth_nonce` and its code is empty or already delegated[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=5,This%20is%20a%20delegation%20indicator).
        

These rules must be enforced _before_ the transaction is executed. Currently, `ToSignedFilecoinMessage` only checks the outer signature using the sender’s secp256k1 public key. We will need to extend `Eth7702TxArgs` with a method like `ValidateAuthorizations(stateManager)` that:

* Iterates over each authorisation tuple, recovers the authority address using `ecrecover`, verifies the signature bounds, and checks state (nonce, code).
    
* Adds the authority to `accessed_addresses` to warm it for EIP‑2929 gas accounting.
    
* Computes gas refunds or charges per EIP‑7702 rules.
    

Failure to implement these validations risks processing invalid delegations or leaving the node vulnerable to replay and griefing attacks. From a developer’s point of view, correct error handling is critical: transaction submission should return clear reasons for rejection so they can correct signatures or nonces.

#### 4.4 Account Code Updates and Actor Integration

**Where it matters**: `chain/actors/builtin/evm/evm.go` and possibly new actor code.

EOAs in Lotus currently have no code and cannot delegate to another contract. To support EIP‑7702, we need a mechanism to write a _delegation indicator_ (`0xef0100 || auth_address`) into the `authority` account’s code and increment its nonce[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=7.%20Add%20%60PER_EMPTY_ACCOUNT_COST%20,by%20one). There are two principal design options:

1. **Extend the EVM actor**: Modify the EVM actor to allow EOAs (account actors) to carry a short code blob representing the delegation indicator. The EVM’s runtime must detect the `0xef` prefix and treat calls to the account as delegated calls. This would require changes to the `evm.go` state loading logic and the execution loop (e.g. in FVM) to follow the delegation pointer for certain opcodes, as specified by the EIP[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20affected%20executing%20operations%20are%3A).
    
2. **Introduce a new system actor**: Create a dedicated actor responsible for storing and interpreting delegation indicators, separate from the EVM actor. The `ToUnsignedFilecoinMessage` for an EIP‑7702 transaction would call this actor’s method, which would validate authorisations and update account state accordingly. The EVM runtime would check this actor to resolve delegation indicators during execution. This isolates the new functionality but requires additional syscall wiring.
    

Whichever route is chosen, the message conversion layer must set the correct method ID and parameters so that the FVM can effect the state change. Developers will not see these details directly, but if the mapping is incorrect, transactions will fail silently or behave inconsistently across nodes.

#### 4.5 Gas Computation and Estimation

**Where it matters**: `node/impl/eth/gas.go`, `node/impl/eth/estimate.go`, and the FVM.

EIP‑7702 introduces new intrinsic costs and refunds based on the length of the authorisation list and whether the authority accounts are empty. Current gas price and fee history functions (`EthGasPrice`, `EthFeeHistory`) will continue to work, but `EthEstimateGas` must be updated to:

* Add `PER_EMPTY_ACCOUNT_COST * len(authorization_list)` to the intrinsic gas[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=).
    
* Include potential `COLD_ACCOUNT_READ_COST` charges for each authority when accessing delegated code[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20transaction%20sender%20will%20pay,regardless%20of%20validity%20or%20duplication).
    
* Account for the gas refunded or charged when writing delegation indicators (empty vs. non‑empty code).
    

Because gas estimation simulates the call via the FVM, we must ensure that the simulation logic processes the authorisation list before executing the calldata, in exactly the same way as mainnet. Otherwise, developers may see under‑ or over‑estimates that cause their transactions to revert.

Additionally, the message pool’s gas limit heuristics may need adjustment to consider the increased intrinsic gas and potential nonce increments for authority accounts. If a set‑code transaction touches multiple accounts, it could invalidate pending messages from those accounts; the mempool should be aware of this to prevent reordering issues.

#### 4.6 Transaction Propagation and Mempool Policy

**Where it matters**: `mpool`, `chain/indexer`, networking layer.

EIP‑7702 complicates transaction propagation in two ways:

* **Cross‑account invalidation**: Setting a delegation on an EOA increments the authority’s nonce, which can invalidate pending transactions from that account[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Allowing%20EOAs%20to%20behave%20as,pending%20from%20the%20sender%E2%80%99s%20account). Lotus currently tracks nonces per sender to evict stale messages, but it assumes one transaction only affects the sender. The mempool will need logic to detect when a type‑4 transaction targets an authority and remove or reprioritise pending messages from that authority.
    
* **Pending transaction limits**: The EIP recommends that clients do not accept more than one pending transaction per delegated EOA[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=While%20there%20are%20a%20few,invalidated%20by%20a%20single%20transaction) to minimise stale transactions. Implementing this policy may involve rejecting additional pending transactions or warning RPC callers that the account already has a delegation pending.
    

From a developer standpoint, these rules may be surprising: sending a set‑code transaction could cause other messages to be dropped. Clear RPC error messages and documentation will be essential to avoid confusion.

#### 4.7 Logging and Receipts

**Where it matters**: `node/impl/eth/transaction.go`, `events.go`, `common/EthTx` and `EthReceipt` types.

Receipts for EIP‑7702 transactions will still use the standard EIP‑2718 payload format `rlp([status, cumulativeGasUsed, logsBloom, logs])`[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20EIP,status%2C%20cumulative_transaction_gas_used%2C%20logs_bloom%2C%20logs). However, the logs themselves may be emitted by delegated contracts rather than the sender’s account. The transaction retrieval code must:

* Include the `authorization_list` in the returned `EthTx` so that clients can inspect which accounts were delegated.
    
* Generate accurate logs and log blooms based on the executed code at `auth_address`.
    
* Reflect the final state of the authority’s delegation indicator (so explorers can show that the EOA is now delegated).
    

Event subscription logic (`EthGetLogs`, filter handling) must be able to match events emitted during delegated execution even though the transaction’s `from` is an EOA. Developers relying on event filtering should not need to update their code; the node should handle the complexity internally.

* * *

Overall, adopting EIP‑7702 requires modifications across the entire Eth‑RPC stack, from parsing through execution to receipt generation. By carefully analysing each area and planning changes that preserve developer expectations, Lotus can provide seamless support for the new transaction type without compromising the existing developer experience.


### 5. High‑Level Design Proposal

Having analysed how EIP‑7702 impacts the Lotus stack, the next step is to outline a concrete approach for adding support. This design focuses on minimising disruption to existing workflows while faithfully implementing the EIP. It is intentionally high‑level; detailed interfaces and code will be defined in later phases.

#### 5.1 Data Type Additions

**New transaction struct – `Eth7702TxArgs`**

* Define a Go struct in `chain/types/ethtypes/eth_7702_transactions.go`:
    
    ```go
    type EthAuthorization struct {
        ChainID EthUint64
        Address EthAddress
        Nonce   EthUint64
        YParity uint8
        R       EthBigInt
        S       EthBigInt
    }
    
    type Eth7702TxArgs struct {
        ChainID             EthUint64
        Nonce               EthUint64
        MaxPriorityFeePerGas EthBigInt
        MaxFeePerGas         EthBigInt
        GasLimit             EthUint64
        Destination          EthAddress
        Value               EthBigInt
        Data                EthBytes
        AccessList           []AccessTuple
        AuthorizationList    []EthAuthorization
        SigYParity           uint8
        SigR, SigS           EthBigInt
    }
    ```
    
* Implement the `EthTransaction` interface on `Eth7702TxArgs`, ensuring each method follows the spec:
    
    * `Type()` returns `0x04`.
        
    * `ToRlpUnsignedMsg()` encodes the outer fields plus `authorization_list`.
        
    * `ToRlpSignedMsg()` prefixes the type byte and appends the signature.
        
    * `TxHash()` computes `keccak256(0x04 || RLP(payload))`.
        
    * `Signature()` returns the outer `(r, s, v)` values.
        
    * `Sender()` recovers the sender from the outer signature.
        
    * `ToUnsignedFilecoinMessage()` returns a Filecoin message with the appropriate method and parameters (described in §5.3).
        
    * Additional helper: `ValidateAuthorizations(stateMgr)` (see §5.4).
        

**Extend existing types**

* Add an `AuthorizationList` field to `EthTx` for RPC responses. Represent each authorisation as a nested slice or a struct with fields matching the RLP order. Use `omitempty` tags to preserve backwards compatibility.
    
* Define constants for the new type and gas parameters in `eth_types.go` (e.g. `SetCodeTxType = 0x04`, `PerAuthBaseCost = 12500`, etc.).
    

From a developer’s standpoint, these additions ensure that the RPC can faithfully encode and decode EIP‑7702 transactions. Wallet and SDK authors can import the new structs and leverage existing JSON tags without redesigning their tooling.

#### 5.2 Parser Extension

Modify `ParseEthTransaction` so that when the first byte of a transaction is `0x04` (or when the outer envelope indicates type `0x04`), it calls a new `parseEIP7702Tx` function:

```go
func parseEIP7702Tx(raw []byte) (*Eth7702TxArgs, error) {
    // strip type byte if present
    // decode RLP into the 11 expected fields
    // ensure authorization_list has at least one element
    // convert each element into an EthAuthorization struct
    // populate outer fields and signature values
}
```

The parser should validate basic structural requirements (e.g. correct number of fields, non‑empty authorisation list) and leave state‑dependent checks to `ValidateAuthorizations`. This separation keeps parsing logic consistent with existing transaction types.

#### 5.3 Message Conversion Strategy

The core question is how to map an EIP‑7702 set‑code transaction into a Filecoin message so that the delegation indicator is written and subsequent calls behave correctly. Two design options were discussed in §4.4; the proposal here assumes **Option 1**—extending the EVM actor—which offers tighter integration with existing execution semantics.

**Proposed approach:**

* **Define a new EVM actor method** (e.g. `ExecSetCodeEOA`) that takes as parameters an array of authorisation tuples and the gas fee parameters. The method:
    
    1. Validates each tuple: checks chain ID, recovers `authority` via signature, verifies nonce and emptiness of code, and adds `authority` to the accessed addresses (for gas accounting).
        
    2. Writes the delegation indicator (`0xef0100 || address`) to the `authority`’s code or clears it if `auth.address` is zero.
        
    3. Increments the nonce of `authority`.
        
    4. Accumulates gas refunds for empty‑account delegations.
        
* **In `Eth7702TxArgs.ToUnsignedFilecoinMessage`**, set:
    
    * `From` as the sender’s Filecoin address.
        
    * `To` as the EVM actor address.
        
    * `Method` as the new `ExecSetCodeEOA` method number.
        
    * `Params` as the RLP‑encoded authorisation list and possibly other call data (the outer transaction’s `data` field).
        
    * Gas fields and value as in EIP‑1559.
        
* The FVM/EVM runtime must detect accounts with delegation indicators during call execution. When a call targets an EOA with code beginning `0xef0100`, it resolves the delegate address and executes that code in the context of the authority.
    

This mapping preserves the developer’s model of “one transaction, one operation”: the outer transaction becomes a single message that writes delegations and then (optionally) executes the calldata on the sender account. Developers building on Lotus only need to set `type: 0x04` and include the `authorization_list`; the rest is handled internally.

Should the project opt for **Option 2** (a new system actor), the conversion would instead call that actor’s method. The differences are primarily internal; the RPC layer stays the same.

#### 5.4 Security Validations

To enforce the EIP’s signature and nonce rules, implement a method on `Eth7702TxArgs` such as:

```go
func (tx *Eth7702TxArgs) ValidateAuthorizations(sm stateManager) error {
    for _, auth := range tx.AuthorizationList {
        // Chain ID check
        if auth.ChainID != 0 && auth.ChainID != tx.ChainID {
            return fmt.Errorf("invalid auth chain id")
        }
        // Recover authority
        msg := keccak256(append(MagicPrefix, rlp.Encode([]interface{}{auth.ChainID, auth.Address, auth.Nonce})))
        pubKey := ecrecover(msg, auth.YParity, auth.R, auth.S)
        authority := EthAddressFromPubKey(pubKey)
        // Low-s check
        if !isLowS(auth.S) { return fmt.Errorf("high s value") }
        // State checks
        acc := sm.GetAccount(authority)
        if acc.Nonce != auth.Nonce { return fmt.Errorf("nonce mismatch") }
        if !acc.CodeIsEmpty() && !acc.CodeIsDelegationIndicator() {
            return fmt.Errorf("code must be empty or already delegated")
        }
        // Warm up authority for gas accounting
        sm.MarkAccessed(authority)
    }
    return nil
}
```

`EthSendRawTransaction` should call `ValidateAuthorizations` after parsing and before pushing the message. If validation fails, return a well‑structured JSON‑RPC error indicating which tuple was invalid. This encourages developers to correct their input without needing to dig into node logs.

#### 5.5 Backward Compatibility and Developer API

A guiding principle of this design is to **avoid introducing new RPC endpoints**. EIP‑7702 transactions should be submitted using the same `eth_sendRawTransaction` or `eth_sendTransaction` methods already supported. Likewise, `eth_getTransactionByHash`, `eth_getTransactionReceipt` and related methods must continue to return results compatible with the broader Ethereum ecosystem, with the addition of the `authorization_list` field when applicable. This approach ensures:

* **Wallet compatibility**: Wallets that understand typed transactions and can construct a `type: 0x04` payload will work with Lotus without code changes.
    
* **Minimal tooling updates**: Libraries like ethers.js or web3.js will only need to add support for the new type and authorisation encoding.
    
* **Consistent developer experience**: Developers interacting with Lotus will not need to learn new APIs; they can reuse existing code patterns for sending transactions, estimating gas and fetching receipts.
    

To further ease adoption, we should provide developer documentation and code examples illustrating how to create and sign an EIP‑7702 transaction using common libraries, how to include multiple authorisations, and how to interpret the resulting receipt.

* * *

This high‑level design balances fidelity to the EIP specification with practical implementation considerations in Lotus. It preserves the familiar Eth‑RPC interface, introduces clear data types for the new transaction fields and outlines a path for modifying the EVM actor to handle delegation indicators. Subsequent work will flesh out these proposals with concrete code, tests and security audits.


### 6. Open Questions & Risks

While the high‑level design provides a roadmap for EIP‑7702 support, several decisions remain unresolved and potential pitfalls deserve attention. Addressing these questions early will help avoid costly redesigns later and will inform the next phases of development.

#### 6.1 Actor Design Choice

The proposal outlines two possibilities: extend the existing EVM actor or introduce a new system actor dedicated to delegation indicators. Key considerations include:

* **State layout and versioning**: Extending the EVM actor requires adding delegation indicator handling to all supported actor versions (v12, v13, v14, etc.) and ensuring upgrades preserve existing code and state. Introducing a new actor avoids touching existing EVM state but adds a dependency for delegation resolution during calls.
    
* **Execution overhead**: Delegation resolution must run in the execution loop for every call. Adding this logic to the EVM actor may be more efficient because it can be integrated into opcode handlers, but it increases complexity. A separate actor could encapsulate logic but may require additional FVM syscalls for each call to delegated EOAs.
    
* **Security and auditing**: A new actor can be audited in isolation. Modifying the EVM actor might introduce subtle bugs affecting all contracts.
    

**Risk**: Choosing the wrong design could lead to performance penalties or state‑migration headaches. A careful evaluation of FVM architecture, benchmarking and community feedback is needed before committing.

#### 6.2 Storage Clearing and Migration

EIP‑7702 allows changing delegation on an account repeatedly. Smart contract wallets must avoid storage collisions when switching between delegate contracts[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Changing%20an%20account%E2%80%99s%20delegation%20is,upgrade%20to%20the%20old%20one). In Ethereum, this responsibility falls on contract developers, who can use patterns like [ERC‑7201] namespaced storage. In Lotus:

* If the delegation indicator is stored in the EVM actor’s code field, clearing or changing it will not automatically clear the authority’s storage. Developers may need to send a separate transaction to reset storage or design delegates that handle migrations safely.
    
* If a new actor stores the delegation indicator, storage clearing may be simpler, but contract authors still need to avoid collisions.
    

**Risk**: Without clear guidelines, developers may build delegates that leave residual state or unintentionally overwrite storage. Lotus documentation must highlight best practices, and tooling might need to provide helpers for safe migrations.

#### 6.3 Gas Estimation Accuracy

Accurate gas estimation is critical for a good developer experience. EIP‑7702 introduces conditional refunds (`PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST`) and additional read costs when following delegation chains[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=). The intrinsic gas also depends on the number of authorisations. Questions include:

* How do we simulate delegation resolution and gas refunds during `eth_estimateGas`? The simulation must mirror the FVM’s behaviour but should not persist state changes.
    
* What happens if the authority’s code is non‑empty but delegated? The specification allows delegating only empty or already delegated accounts, but in a cross‑chain or replay scenario, an EOA might appear non‑empty. Gas estimation must handle such corner cases gracefully.
    
* Should the FVM maintain a separate state copy for gas estimation with temporarily written delegation indicators? This could impact performance.
    

**Risk**: Incorrect gas estimation could cause transactions to fail (under‑estimation) or overpay fees (over‑estimation), damaging developer confidence. Extensive testing and perhaps a separate simulation state mechanism will be needed.

#### 6.4 Mempool and Transaction Propagation

Supporting EIP‑7702 transactions implies:

* **Cross‑account nonce updates**: Delegating an EOA increments its nonce, invalidating pending transactions from that authority[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Allowing%20EOAs%20to%20behave%20as,pending%20from%20the%20sender%E2%80%99s%20account). How should the mempool respond? Should it automatically prune all pending messages from the authority? Could this be exploited for denial‑of‑service attacks?
    
* **Pending transaction limits**: The spec recommends clients accept at most one pending transaction per delegated account[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=While%20there%20are%20a%20few,invalidated%20by%20a%20single%20transaction). Implementing this limit may require changes in p2p transaction propagation and block‑template selection.
    
* **Propagation rules**: Should peers propagate EIP‑7702 transactions differently (e.g. gating by number of authorisations) to prevent spam? How do we discourage oversized authorisation lists?
    

**Risk**: Without careful policy, malicious actors could craft transactions that churn nonces and evict honest messages, or flood the network with large authorisation lists. Future phases must define mempool rules and network heuristics to mitigate this.

#### 6.5 Interaction with Other Account Abstraction Efforts

EIP‑7702 arrives in the broader context of account abstraction proposals like ERC‑4337 and EIP‑5003. While EIP‑7702 is simpler—it temporarily delegates code to a single contract—it may overlap in functionality. Questions to consider:

* How will Lotus prioritise EIP‑4337 support relative to EIP‑7702? Are there synergies in implementing both (e.g. shared actor infrastructure, entry point contracts)?
    
* If an account uses both ERC‑4337 and EIP‑7702, what is the precedence of delegation vs. alternate “Account Abstraction” paths?
    
* Could EIP‑7702 serve as a stepping stone to full account abstraction, or will developers use it primarily for simple batching and sponsorship?
    

**Risk**: Diverging implementations of account abstraction could confuse developers. Lotus should coordinate with the wider Ethereum community and consider aligning EIP‑7702 support with future proposals to ensure consistency.

#### 6.6 Cross‑Chain and Replay Concerns

EIP‑7702’s authorisation tuples include a `chain_id` field. The spec allows this to be zero or the current chain ID[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=For%20each%20%60,tuple%2C%20perform%20the%20following). A zero value means the authorisation is chain‑agnostic and could be replayed on other networks. For multi‑chain wallets:

* Should Lotus accept zero as a valid `auth_chain_id`? Doing so might enable cross‑chain delegation, which has security implications.
    
* How should wallets indicate to users that their authorisation might be usable on another chain? Should there be UI warnings?
    

**Risk**: Users might unknowingly sign authorisations that can be replayed elsewhere, leading to unintended code delegation. Client libraries and Lotus itself might need to restrict or warn about zero `auth_chain_id` values.

#### 6.7 Documentation and Tooling

Finally, the success of EIP‑7702 depends on clear documentation and robust tooling. Developers must know how to construct the `authorization_list`, sign tuples correctly and interpret receipts. There are risks that:

* Without official examples and templates, developers may create malformed transactions that Lotus rejects.
    
* Wallets may incorrectly implement the spec, leading to interoperability issues.
    
* Block explorers and debuggers might misrepresent delegated EOAs as contract accounts or fail to show the delegation indicator.
    

To mitigate these risks, the Lotus team should plan for:

* Comprehensive documentation, including example transactions and step‑by‑step signing instructions.
    
* Test vectors and conformance tests shared with ecosystem partners.
    
* Updates to dev tooling (CLI, SDKs) to support `0x04` transactions.
    

* * *

Identifying these open questions now allows stakeholders to discuss design choices, align with broader ecosystem goals and prioritise additional research. As the project progresses into implementation, some of these risks will be addressed through benchmarks, security reviews and community feedback.

* * *


### 7. Implementation Roadmap (Detailed)

Expanding the roadmap with more concrete tasks and deliverables helps ensure that nothing falls through the cracks. The phases are designed to be executed sequentially, with clear entry and exit criteria. Each phase references specific files, modules and tooling that will be affected.

#### Phase 0: Planning and Team Alignment

* **Design freeze and specification**:
    
    * Produce a formal Lotus EIP‑7702 specification document based on Section 5, including UML diagrams of actor state transitions and call sequences.
        
    * Resolve outstanding questions such as actor choice (extended EVM vs. new system actor) and chain‑agnostic authorisations by convening maintainers and FVM developers.
        
    * Map out FVM interface changes (e.g. new syscalls) if required by the chosen design.
        
* **Resource planning**:
    
    * Assign owners for each phase, with estimated timelines and dependencies.
        
    * Establish a shared branch or feature flag to avoid destabilising `master`.
        
    * Set up CI jobs and linting rules for new modules (e.g. `eth_7702_transactions.go`).
        

_Deliverables_: Approved implementation spec, project plan with milestones and assigned engineers.

#### Phase 1: Type and Parser Infrastructure

* **Add EIP‑7702 constants**: In `chain/types/ethtypes/eth_types.go`, define `SetCodeTxType`, `MagicNumber`, `PerAuthBaseCost` and `PerEmptyAccountCost`. Provide Go doc comments linking back to the EIP.
    
* **Create `EthAuthorization` and `Eth7702TxArgs`**:
    
    * Place in a new file `chain/types/ethtypes/eth_7702_transactions.go`.
        
    * Ensure fields use existing wrapper types (`EthUint64`, `EthBigInt`, `EthAddress`) to keep consistent JSON encoding.
        
    * Add tags like `json:"authorizationList"` for RPC encoding.
        
* **Implement `EthTransaction` methods**:
    
    * `Type()` returns `4`; `ToRlpUnsignedMsg()` uses `rlp.Encode` to encode the outer fields and `authorizationList`.
        
    * `ToRlpSignedMsg()` prepends the type byte and appends `SigYParity`, `SigR`, `SigS`.
        
    * `TxHash()` and `Signature()` follow the EIP‑2718 pattern.
        
    * Use unit tests to compare generated RLP bytes against fixtures (to be created).
        
* **Extend existing parser**:
    
    * In `eth_transactions.go`, add a case `case 0x04` to call `parseEIP7702Tx`.
        
    * Write `parseEIP7702Tx` using the go‑ethereum `rlp` package to decode the tuple. Validate list length (must be ≥ 11), ensure the `authorizationList` is non‑empty, and convert sub‑tuples into `EthAuthorization`.
        
* **Unit tests**:
    
    * Create `chain/types/ethtypes/eth_7702_transactions_test.go` with tests that:
        
        * Encode a known EIP‑7702 transaction (outer and nested signatures omitted) and verify the parser constructs the correct struct.
            
        * Round‑trip encoding/decoding yields identical bytes.
            
        * Reject empty `authorizationList` or malformed tuples.
            

_Exit criteria_: CI passes with new tests; the parser recognises type 4 transactions but does not yet convert or execute them.
##### 1. Core Type Definitions

###### 1.1 `chain/types/ethtypes/eth_types.go`

1. **Add constants** at the top of the file (alongside existing type constants):
    
    ```go
    const (
        SetCodeTxType         uint8 = 0x04
        SetCodeMagic          = 0x05
        PerAuthBaseCost       = 12500
        PerEmptyAccountCost   = 25000
    )
    ```
    
2. **Extend `EthTx` struct** to include the authorisation list:
    
    ```go
    // EthTx represents a decoded Ethereum transaction.
    type EthTx struct {
        // existing fields...
        AuthorizationList []EthAuthorization `json:"authorizationList,omitempty"`
    }
    ```
    
3. **Define a new struct** for authorisation tuples:
    
    ```go
    type EthAuthorization struct {
        ChainID EthUint64  `json:"chainId"`
        Address EthAddress `json:"address"`
        Nonce   EthUint64  `json:"nonce"`
        YParity uint8      `json:"yParity"`
        R       EthBigInt  `json:"r"`
        S       EthBigInt  `json:"s"`
    }
    ```
    
4. **Add JSON marshalling/unmarshalling tests** verifying that `EthTx` correctly encodes/decodes an `authorizationList`. Place these in `eth_types_test.go`.
    

###### 1.2 New file: `chain/types/ethtypes/eth_7702_transactions.go`

1. **Create `Eth7702TxArgs` struct** implementing `EthTransaction`:
    
    ```go
    type Eth7702TxArgs struct {
        ChainID             EthUint64
        Nonce               EthUint64
        MaxPriorityFeePerGas EthBigInt
        MaxFeePerGas         EthBigInt
        GasLimit             EthUint64
        Destination          EthAddress
        Value               EthBigInt
        Data                EthBytes
        AccessList          []AccessTuple
        AuthorizationList   []EthAuthorization
        SigYParity           uint8
        SigR, SigS           EthBigInt
    }
    ```
    
2. **Implement all methods** from the `EthTransaction` interface:
    
    * `Type() uint8` returns `SetCodeTxType`.
        
    * `ToRlpUnsignedMsg() []byte` RLP‑encodes the first 10 fields (excluding signature).
        
    * `ToRlpSignedMsg() []byte` prefixes type byte (`SetCodeTxType`) and appends `SigYParity`, `SigR`, `SigS`.
        
    * `TxHash() (common.EthHash, error)` computes `keccak256(type || RLP(payload))`.
        
    * `Signature() (r, s, v *big.Int, err error)` returns `(SigR.Big(), SigS.Big(), new(big.Int).SetUint64(uint64(SigYParity)), nil)`.
        
    * `Sender()` recovers the sender from the outer signature using the standard ECDSA recovery over the hash.
        
    * `ToUnsignedFilecoinMessage()` will be implemented in Phase 2 to construct the Filecoin message.
        
    * `ToEthTx()` populates the `EthTx` struct, including the `AuthorizationList`.
        
    * `ToVerifiableSignature()` returns the signature and message digest for block verification.
        
3. **Add a constructor or helper** for `EthAuthorization` signature validation (used in `ValidateAuthorizations`).
    
4. **Unit tests**:
    
    * `TestParseEth7702Transaction`: RLP‑encode a known EIP‑7702 payload (without the outer signature), prefix with the type byte, and verify `ParseEthTransaction` returns an `Eth7702TxArgs` with the correct fields.
        
    * `TestEth7702TxArgs_RLPEncoding`: Ensure `ToRlpUnsignedMsg` and `ToRlpSignedMsg` match the expected RLP sequences.
        
    * `TestEth7702TxArgs_TxHash`: Compare the computed hash against a fixture.
        
#### Phase 2: Message Conversion and Actor Support

* **Extend or add actor code**:
    
    * **Extended EVM actor**:
        
        * In `chain/actors/builtin/evm`, add a new method number (e.g. `EvmMethodSetDelegation`) in the actor’s ABI file.
            
        * Update state structs to include a `Delegated` boolean or pointer to `delegateAddress`.
            
        * Implement the method in each actor version: validate authorisations (call FVM syscalls for signature verification), write the delegation indicator to the account’s code and increment the nonce.
            
        * Modify the EVM execution engine (FVM) to check for delegation indicator when executing account code; update opcodes `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL`, `CODESIZE`, `CODECOPY` accordingly.
            
    * **New system actor**:
        
        * Add a new actor under `chain/actors/builtin/delegator` with a method `ApplyDelegations`. Keep EVM actor unchanged; calls to delegated EOAs will check this actor for a delegation record.
            
        * Implement state (mapping of EOA addresses to delegates) and methods similar to the extended EVM actor approach.
            
* **Update `Eth7702TxArgs.ToUnsignedFilecoinMessage()`**:
    
    * Set `To` to the actor address (EVM or Delegator).
        
    * Convert `authorizationList` into FVM parameters: use `cborutil` to encode an array of `{authority, address, nonce, yParity, r, s}`.
        
    * Preserve the outer `data` field: if present, include it as calldata to be executed after delegations are applied.
        
* **Integrate in send flow**:
    
    * In `node/impl/eth/send.go`, after parsing a type‑4 transaction:
        
        * Call `tx.ValidateAuthorizations(stateManager)` to perform state‑dependent checks (see below).
            
        * Convert to a `types.Message` via `ToUnsignedFilecoinMessage()`.
            
        * Sign with the outer signature via `ToSignedFilecoinMessage()`; ensure the `SignatureData` uses the sender’s SECP key.
            
        * Push via `MpoolPush` or `MpoolPushUntrusted`.
            
    * Update the chain indexer to store the raw transaction bytes and note that the transaction type is 4.
        
* **Implement `ValidateAuthorizations`**:
    
    * In the new `eth_7702_transactions.go` file, implement state‑dependent verification:
        
        * Use `stateManager.ResolveAddress` and `stateManager.GetActorState` to fetch account data.
            
        * Call FVM syscalls or internal helpers to verify secp256k1 signatures (enforcing low‑s).
            
        * Check code hash equals the empty code hash or has the `0xef0100` prefix; treat non‑matching code as invalid.
            
        * Increment a gas tracker if a refund is due for empty code.
            
    * Write tests using the Lotus test harness to ensure invalid authorisations are rejected with descriptive errors.
        

_Exit criteria_: The node can accept, parse and enqueue type‑4 transactions without panicking; the actor code is in place and test delegations update account code as expected in a local devnet.

##### 2. Parser Integration

###### 2.1 `chain/types/ethtypes/eth_transactions.go`

1. **Modify the type dispatch** in `ParseEthTransaction(raw []byte)`:
    
    ```go
    // existing code that strips the type byte for typed transactions
    if txType == SetCodeTxType {
        return parseEIP7702Tx(body)
    }
    ```
    
2. **Implement `parseEIP7702Tx`** in `eth_7702_transactions.go`:
    
    ```go
    func parseEIP7702Tx(raw []byte) (*Eth7702TxArgs, error) {
        var fields []interface{}
        if err := rlp.DecodeBytes(raw, &fields); err != nil {
            return nil, err
        }
        if len(fields) != 11 {
            return nil, fmt.Errorf("expected 11 fields, got %d", len(fields))
        }
        // Decode each field into the appropriate EthX type.
        // Decode authorization list into []EthAuthorization.
        // Return an instance of Eth7702TxArgs.
    }
    ```
    

3. **Write parsing tests** in `eth_transactions_test.go` to verify dispatching and error handling (e.g. wrong field count, empty authorisation list).


##### Message Conversion and Actor Integration

###### 3.1 `node/impl/eth/send.go`

1. **Add a new case** in `ethSendRawTransaction` after parsing:
    
    ```go
    if tx.Type() == ethtypes.SetCodeTxType {
        eth7702Tx := tx.(*ethtypes.Eth7702TxArgs)
        // Validate authorisations via state manager
        if err := eth7702Tx.ValidateAuthorizations(n.api.StateManager); err != nil {
            return zeroHash, err
        }
        // Build Filecoin message
        smsg, err := eth7702Tx.ToSignedFilecoinMessage(n.api.StateManager)
        if err != nil {
            return zeroHash, err
        }
        // Mpool push logic remains the same.
    }
    ```
    
2. **Ensure that for untrusted senders**, the code path still performs signature and nonce checks before adding to the pool.
    

###### 3.2 `Eth7702TxArgs.ValidateAuthorizations`

Implement this method in `eth_7702_transactions.go`:

```go
func (tx *Eth7702TxArgs) ValidateAuthorizations(sm state.Manager) error {
    for i, auth := range tx.AuthorizationList {
        if auth.Nonce.Big().BitLen() > 64 {
            return fmt.Errorf("authorization[%d]: nonce out of range", i)
        }
        if auth.ChainID != 0 && auth.ChainID != tx.ChainID {
            return fmt.Errorf("authorization[%d]: chain id mismatch", i)
        }
        // Reconstruct message: MAGIC || rlp([chain_id, address, nonce])
        var msg bytes.Buffer
        msg.WriteByte(SetCodeMagic)
        msg.Write(rlp.EncodeToBytes([]interface{}{auth.ChainID, auth.Address, auth.Nonce}))
        // Perform ecrecover and low-s check
        pub, err := crypto.Ecrecover(msg.Bytes(), auth.R.Big(), auth.S.Big(), auth.YParity)
        if err != nil {
            return fmt.Errorf("authorization[%d]: bad signature: %w", i, err)
        }
        authority := common.EthAddressFromPubKey(pub)
        // Fetch account from state
        act, err := sm.GetActor(context.Background(), authority)
        if err != nil {
            return fmt.Errorf("authorization[%d]: cannot load actor: %w", i, err)
        }
        // Check nonce and code
        if act.Nonce != auth.Nonce.Uint64() {
            return fmt.Errorf("authorization[%d]: nonce mismatch", i)
        }
        if len(act.Code) > 0 && !bytes.HasPrefix(act.Code, []byte{0xef, 0x01, 0x00}) {
            return fmt.Errorf("authorization[%d]: actor has non-delegation code", i)
        }
        // Warm the account for gas estimation
        sm.AccessAccount(authority)
    }
    return nil
}
```

3. **Unit tests**:
    
    * `TestValidateAuthorizations`: Construct a mock state manager with in-memory actors; test valid and invalid tuples (wrong nonce, wrong chain ID, high-s signatures).
        
    * Use the FVM signature verifier to ensure compatibility with runtime.
        

###### 3.3 Actor support (EVM or new actor)

Depending on the chosen design:

* **Extended EVM Actor**:
    
    1. In `chain/actors/builtin/evm/vX/evm_actor.go`, increment the `Methods` constant to reserve a new method ID (e.g. `MethodSetDelegation = builtin.MethodHAMT + 5`).
        
    2. Add a function `func (a *Actor) ExecSetDelegation(params []types.DelegationParam) (*Ret, error)` that:
        
        * Calls a helper to validate each authorisation (similar to `ValidateAuthorizations` but within the actor context).
            
        * Writes `0xef0100 || delegateAddress` into the authority’s state (use FVM’s account creation or code setting API).
            
        * Updates the nonce and refunds gas.
            
    3. Write a migration script to update existing EVM actor versions to support this method.
        
* **New Delegator Actor**:
    
    1. Create a new actor directory `chain/actors/builtin/delegator`. Define state with a map from EOA to delegate address.
        
    2. Expose a method `ApplyDelegations(params []DelegationParam)`.
        
    3. Modify the EVM runtime to query this actor when an account has empty code; if a delegate is set, use the delegate’s code.
        

**Tests**:

* Use `lotus test` with a local devnet: send a transaction with a single authorisation; verify that the target EOA’s code changes to the delegation indicator and that subsequent calls to the EOA execute the delegated code.
    
* Test that delegations persist after transaction revert and across blocks.
    
* Test that invalid attempts to set code on a contract account are rejected.

#### Phase 3: Gas Estimation and Fee Market Integration

* **Intrinsic gas computation**:
    
    * Modify `node/impl/eth/gas.go` to add a function `CalculateIntrinsicGas7702(tx *Eth7702TxArgs)` returning `21000 + calldataCost + accessListCost + PerEmptyAccountCost * len(tx.AuthorizationList)`.
        
    * For empty code delegations, compute refunds (`PerEmptyAccountCost - PerAuthBaseCost`) and factor them into `EthEstimateGas`.
        
* **Simulation in `EthEstimateGas`**:
    
    * Enhance the simulation engine to process delegations before executing calldata. This may require a “forked” state copy where delegation indicators are applied transiently.
        
    * Update the `applyMessage` logic used in estimation to handle cross‑account nonce increments.
        
    * Ensure gas refunds are not actually minted in simulation but used to lower the reported gas limit.
        
* **Fee history**:
    
    * Include type‑4 transactions in sampling for `EthFeeHistory`. If they have significantly different gas usage patterns, update weighting logic to avoid skewing estimates.
        
    * Write tests comparing results to reference nodes once EIP‑7702 is active on a public testnet.
        
* **Developer feedback**:
    
    * Provide CLI output that displays intrinsic gas and simulation gas separately for a type‑4 transaction, to aid developers in fee estimation.
        

##### 4. Gas Estimation

###### 4.1 `node/impl/eth/gas.go`

1. **Implement a new function**:
    

```go
func intrinsicGas7702(tx *ethtypes.Eth7702TxArgs) (uint64, error) {
    base, err := intrinsicGasCommon(tx.Data, tx.AccessList)
    if err != nil {
        return 0, err
    }
    return base + PerEmptyAccountCost*uint64(len(tx.AuthorizationList)), nil
}
```

2. **Modify `EthEstimateGas`** to branch on `tx.Type()`:
    

```go
case ethtypes.SetCodeTxType:
    intrinsic, err := intrinsicGas7702(tx)
    // then simulate delegations and call as in EIP-1559
```

3. **Simulation**:
    
    * Use a copy of the state (via `sm.BeginTxn`) to apply delegations and compute gas refunds without affecting persistent state.
        
    * Track cold vs. warm account accesses per EIP‑2929 to adjust gas.
        

**Tests**:

* `TestIntrinsicGas7702` verifying intrinsic gas for various authorisation list lengths.
    
* `TestEstimateGas7702` comparing the returned gas to expected values for simple deployments; confirm that gas is refunded for empty accounts.
    


_Exit criteria_: `eth_estimateGas` returns realistic gas limits for EIP‑7702 transactions; simulation does not modify state; base fee APIs remain backward‑compatible.
    

#### Phase 4: Mempool, Propagation and Indexing

* **Cross‑account nonce tracking**:
    
    * Modify the mempool’s nonce tracking map to handle delegations. When a type‑4 transaction is inserted, for each authorisation tuple:
        
        * Lookup the `authority` account and mark all pending messages from that account as potentially invalid.
            
        * Remove or deprioritise those messages depending on policy (e.g. drop vs. re‑check after delegation).
            
    * Keep a record of delegation transactions and their affected accounts to avoid accepting multiple conflicting delegations.
        
* **Pending transaction limit**:
    
    * Add a mempool parameter `MaxPendingDelegationPerAccount` (default 1). When a new delegation transaction for an authority arrives and one is already pending, reject it with an appropriate error.
        
    * Document this in the RPC error codes so that clients understand why their transaction was refused.
        
* **P2P propagation**:
    
    * Update the gossipsub topic handling to include type‑4 transactions. Implement size checks and cap the maximum number of authorisations per transaction to prevent abuse (e.g. 10 by default).
        
    * Ensure that peers do not relay obviously invalid authorisation tuples (e.g. empty list, wrong chain ID).
        
* **Chain indexing**:
    
    * Extend the `chain/indexer` to record the `authorizationList` in a new column. This allows `EthGetTransactionByHash` to reconstruct the full `EthTx`.
        
    * Record the new code hash of delegated EOAs so that block explorers can identify delegated accounts.
        

_Exit criteria_: The mempool and networking layers maintain integrity in the presence of EIP‑7702 transactions, and developers receive informative errors for unsupported scenarios.


#### Phase 5: Receipt, Logging and RPC Adjustments

* **Transaction receipts**:
    
    * Update `node/impl/eth/transaction.go` to include `AuthorizationList` and delegation information in `EthTx` and `TransactionReceipt`. For example, receipts could contain an additional field `delegatedCodeAddress` for each authority.
        
    * Ensure `status` is correctly set (1 for success, 0 for failure) even when delegations succeed but calldata reverts.
        
* **Log handling**:
    
    * Modify `node/impl/eth/events.go` and the log filtering engine to treat logs emitted by delegated code as originating from the delegate address (for `address` field) while still exposing the original `from` in the transaction. Clarify this behaviour in documentation.
        
    * Update bloom filter generation to include delegated contract addresses so that `eth_getLogs` returns correct results.
        
* **eth_call & eth_estimateGas**:
    
    * When `from` points to a delegated EOA, transparently execute the call using the delegate’s code. The call semantics should mirror what happens on-chain.
        
    * Add tests verifying that `eth_call` with a delegated `from` returns the same result as calling the delegate directly.
        

##### Receipt and RPC Updates

###### `node/impl/eth/transaction.go`

1. **Include `AuthorizationList` in `EthTx`** when marshalling transaction details. Modify the code path populating `EthTx` from `SignedMessage` to call `ToEthTx()` on `Eth7702TxArgs`.
    
2. **Receipt fields**: When constructing `TransactionReceipt` for a type‑4 transaction:
    
    * Populate `logs` from delegated execution.
        
    * Set `contractAddress` to empty (EIP‑7702 does not deploy new contracts).
        
    * Include an optional `delegations` array listing the authority accounts and their delegate addresses.
        

**Tests**:

* `TestReceipt7702`: Send a delegation plus a contract call, verify the receipt fields.
    
* `TestGetTransactionByHash7702`: Ensure `eth_getTransactionByHash` returns the `authorizationList`.
    

###### `node/impl/eth/events.go`

* Update log matching to treat delegated EOAs as emitting events from the delegate’s address. This may require an additional state lookup during filtering.
    

**Tests**:

* `TestGetLogsDelegated`: Create a filter for an event emitted by the delegate; send a call via a delegated EOA; verify the event is returned.
    

_Exit criteria_: RPC responses for EIP‑7702 transactions are correct and comprehensive, and clients can fetch logs and receipts without additional work.



##### 5. Mempool and Propagation

###### 5.1 `node/impl/eth/send.go` and `node/modules/mpool` (or equivalent)

1. **Cross‑account invalidation**:
    
    * When accepting a type‑4 transaction, extract the list of authority addresses (from `ValidateAuthorizations`) and, for each, remove all pending messages in the mempool where `msg.From` matches the authority.
        
    * Add a mempool entry index by EOA to facilitate quick removal.
        
2. **Pending transaction limit**:
    
    * Maintain a map `pendingDelegations map[EthAddress]bool`. When adding a new delegation, check this map; if true, reject with `ErrPendingDelegation`.
        
    * Remove from the map when the delegation transaction is mined or replaced.
        

**Tests**:

* `TestMempoolDelegationEviction`: Send a normal transaction from an account, then send a delegation affecting that account; verify that the normal transaction is removed or marked invalid.
    
* `TestMempoolDelegationLimit`: Attempt to send two delegation transactions for the same authority; ensure the second fails.
    

###### 5.2 P2P propagation

* Modify transaction gossip code to check the type byte; if `0x04`, ensure the transaction is not oversized (limit number of authorisations). If over limit, do not propagate to peers.
    

**Tests**:

* Use a simulated network to gossip EIP‑7702 transactions; verify they propagate once and are not dropped erroneously.

    
#### Phase 6: Documentation, Tooling and Developer Outreach

* **Update API docs**:
    
    * Add a dedicated section on EIP‑7702 in the Lotus API docs. Document the structure of the `authorization_list`, transaction examples, and common error codes.
        
    * Provide a matrix comparing EIP‑7702 to EIP‑1559 and ERC‑4337, guiding developers on when to choose each mechanism.
        
* **SDK updates**:
    
    * Update the official Lotus Go and JavaScript SDKs to include helper functions for building and signing EIP‑7702 transactions. Offer utility functions to encode authorisation tuples and compute the magic hash.
        
    * Contribute PRs or guides to popular Ethereum libraries (ethers.js, web3.js, viem) demonstrating how to support the new type when interacting with a Lotus node.
        
* **CLI tools**:
    
    * Add a command to `lotus client` or a companion tool (e.g. `lotus-eth`) for encoding/decode EIP‑7702 transactions and verifying authorisation signatures.
        
    * Create documentation and example scripts for common use cases, such as sponsoring a transaction or delegating to a multisig contract.
        
* **Community engagement**:
    
    * Publish blog posts or tutorials showing how EIP‑7702 simplifies dApp flows on Filecoin EVM.
        
    * Host community calls or workshops to gather feedback and answer developer questions.
        

_Exit criteria_: Developers have accessible resources and tooling to adopt EIP‑7702, and initial community feedback is positive.


##### Additional Documentation and Tooling

* Update the `README` and API docs to describe `authorizationList`, show JSON examples and list RPC error codes (`ErrInvalidAuthorization`, `ErrPendingDelegation`, etc.).
    
* Add examples in `docs/examples` demonstrating how to create, sign and send EIP‑7702 transactions using `lotus-cli` and Go SDK.
    
* Provide sample code in `cmd/examples` for multi‑authorisation transactions.
 
#### Phase 7: Testing, Auditing and Release

* **Automated testing**:
    
    * Develop fuzz tests specifically targeting `ValidateAuthorizations`, gas estimation, and mempool eviction logic. These should randomise signature values, nonces and storage conditions.
        
    * Write property-based tests asserting that delegations remain in effect even when the subsequent call fails, as required by the spec[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Note%2C%20if%20transaction%20execution%20results,indicators%20is%20not%20rolled%20back).
        
    * Use the Lotus integration test harness to spin up multi-node devnets, send combinations of EIP‑7702 and regular transactions, and verify consensus on state changes.
        
* **Performance benchmarks**:
    
    * Measure CPU and memory overhead for parsing and verifying large authorisation lists. Determine practical limits on list length and enforce them if necessary.
        
    * Benchmark gas estimation with and without EIP‑7702 logic to ensure the additional simulation costs are acceptable.
        
* **Security audit**:
    
    * Engage external auditors to review signature verification, state management and FVM integration. Focus on potential replay and DoS vectors discussed in Section 6.
        
    * Address findings and publish a report summarising fixes and residual risks.
        
* **Testnet deployment**:
    
    * Roll out EIP‑7702 support behind a feature flag on a public testnet. Encourage ecosystem partners to test real workflows and report issues.
        
    * Monitor network health, transaction propagation and mempool behaviour. Iterate on policies (e.g. pending limits) based on empirical data.
        
* **Mainnet activation**:
    
    * Once testing and auditing are satisfactory, propose a network upgrade (Lotus release) that enables EIP‑7702. Coordinate with Filecoin governance to schedule the upgrade.
        
    * Provide migration instructions and ensure that nodes can safely fall back (e.g. by ignoring type‑4 transactions) if issues arise.
        

##### Test Harness and Integration Tests

* **Integration test file** `venus/e2e/eth_7702_test.go`:
    
    1. Setup a multi-node devnet.
        
    2. Deploy a simple EVM contract (e.g. counter).
        
    3. Delegate an EOA to the contract; confirm calls to the EOA increment the counter.
        
    4. Revert the call and check that the delegation persists.
        
    5. Test gas estimation on the delegation transaction.
        
    6. Verify mempool behaviour when sending subsequent transactions from the delegated EOA.
        
* **Property-based fuzzing** using `testing/quick`:
    
    * Randomise authorisation lists (length, order, fields) and ensure invalid combinations are rejected and valid combinations succeed.
        
* **Performance tests**:
    
    * Measure CPU usage when processing an `authorizationList` of length 1, 10 and 100 to set a realistic limit for mempool acceptance.


_Exit criteria_: EIP‑7702 support is merged into the main release branch, activated on mainnet via a controlled upgrade, and functioning reliably in production.


 
* * *

This detailed roadmap outlines not only **what** needs to be done but also **where** in the codebase the changes will occur and **how** they interact. By treating each phase as its own mini‑project with clear deliverables and exit criteria, the Lotus team can make steady progress while continuously validating assumptions and gathering feedback.

* * *


### 8. References

Below is a curated list of primary references and resources used throughout this document. They provide authoritative details on the Ethereum Improvement Proposals (EIPs) discussed and source code locations in the Lotus project for further exploration.

#### 8.1 Specifications and Standards

* **EIP‑7702: Set Code for EOAs** – The official specification introducing the type‑`0x04` set‑code transaction, defining transaction structure, authorization list semantics, delegation indicator behaviour, gas costs and security considerations[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Specification)[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=rlp%28,access_list%2C%20authorization_list%2C%20signature_y_parity%2C%20signature_r%2C%20signature_s)[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=7.%20Add%20%60PER_EMPTY_ACCOUNT_COST%20,by%20one).  
    [https://eips.ethereum.org/EIPS/eip-7702](https://eips.ethereum.org/EIPS/eip-7702?utm_source=chatgpt.com)
    
* **EIP‑2718: Typed Transaction Envelope** – Describes the mechanism for introducing new transaction types without breaking backwards compatibility. EIP‑7702 leverages this to define a new type tag (`0x04`).
    
* **EIP‑4844** – Defines the semantics for fields in type‑`0x03` (blob) transactions. EIP‑7702 states that outer fields follow the same semantics[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=The%20fields%20,null%20destination%20is%20not%20valid).
    
* **EIP‑2930: Access List Transactions** – Provides the base intrinsic gas calculation used by EIP‑7702.
    
* **EIP‑2929, EIP‑3541, EIP‑3607** – Define cold vs warm storage costs, ban the `0xef` opcode used in the delegation indicator and restrict contract creation by EOAs, respectively. EIP‑7702 modifies or builds upon these rules[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=)[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=).
    

#### 8.2 Lotus Source Code References

* **Gateway proxies** (`gateway/proxy_eth_v1.go`, `gateway/proxy_v2.go`) – Entry points for Ethereum JSON‑RPC requests, forwarding calls like `eth_sendRawTransaction` to the full node[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/gateway/proxy_eth_v1.go#:~:text=return%20nil%2C%20err%20).
    
* **Eth transaction parsing and interface** (`chain/types/ethtypes/eth_transactions.go`) – Defines `EthTransaction` interface methods and dispatches parsing based on transaction type[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_transactions.go#:~:text=%2F%2F%20EthTransaction%20defines%20the%20interface,types.SignedMessage%29%20%28EthTx%2C%20error%29).
    
* **Concrete transaction types**:
    
    * `eth_1559_transactions.go` – Implements EIP‑1559 transactions[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_1559_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29).
        
    * `eth_legacy_155_transactions.go` – Implements EIP‑155 legacy transactions[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_legacy_155_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29).
        
    * `eth_legacy_homestead_transactions.go` – Implements Homestead‑style transactions[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/types/ethtypes/eth_legacy_homestead_transactions.go#:~:text=func%20%28tx%20,w%22%2C%20err%29).
        
* **Eth API implementation** (`node/impl/eth`) – Contains modules for sending transactions (`send.go`), gas estimation (`gas.go`), transaction retrieval (`transaction.go`), event handling (`events.go`) and basic chain info. These files will need updates for EIP‑7702 support.
    
* **Address conversion** (`node/impl/eth/filecoin.go`) – Handles mapping between Ethereum and Filecoin addresses[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/node/impl/eth/filecoin.go#:~:text=ts%2C%20err%20%3A%3D%20e,wrap%2C%20to%20preserve%20ErrNullRound).
    
* **EVM actor** (`chain/actors/builtin/evm/evm.go`) – Provides helpers for loading and creating EVM actor state[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/chain/actors/builtin/evm/evm.go#:~:text=func%20Load%28store%20adt.Store%2C%20act%20,s%22%2C%20name%29); may be extended to handle delegation indicators.
    
* **Subscription handler** (`gateway/eth_sub.go`) – Manages log subscription sinks[raw.githubusercontent.com](https://raw.githubusercontent.com/filecoin-project/lotus/master/gateway/eth_sub.go#:~:text=type%20EthSubHandler%20struct%20,ethtypes.EthSubscriptionResponse%29%20error); will propagate events from delegated EOAs.
    

#### 8.3 Further Reading and Community Resources

* **Ethereum Magicians & Discussions** – Community threads discussing the rationale and evolution of EIP‑7702, including debate on security and migration strategies.
    
* **ERC‑7201: Namespaced Storage** – A proposed standard for avoiding storage collisions in upgradeable contracts, relevant to the storage‑management concerns raised by EIP‑7702[eips.ethereum.org](https://eips.ethereum.org/EIPS/eip-7702#:~:text=Changing%20an%20account%E2%80%99s%20delegation%20is,upgrade%20to%20the%20old%20one).
    
* **QuickNode’s EIP‑7702 Guide** – A high‑level implementation guide for developers, including examples of constructing and testing set‑code transactions.
    
* **ERC‑4337 Account Abstraction** – Provides a contrasting approach to account abstraction via a separate entry point contract; understanding the differences helps developers choose the right abstraction mechanism for their use case.
    

* * *

These references offer both the normative specification details and practical code locations necessary for anyone looking to understand, implement or audit EIP‑7702 support in Lotus.

* * *
